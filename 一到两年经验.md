1.1年(两年的就写两年)单体式项目开发经验，能够独立完成日常的需求开发，熟练使用常用的开发工具。

2.熟练掌握Java基础、面向对象编程思想，并具有良好的编码习惯

#### 基础:

* (1)get和post的区别

* > "GET" 和 "POST" 是 HTTP（超文本传输协议）中两种常用的请求方法。它们的主要区别在于：
  >
  > 1. 参数传递方式：
  > GET 请求将请求参数放置在 URL 的查询字符串中，而 POST 请求则将请求参数放置在请求体中。因此，GET 请求的参数会暴露在 URL 中，而 POST 请求的参数不会暴露在 URL 中，从安全性角度考虑，POST 请求比 GET 请求更安全。
  >
  > 2. 参数传递的大小限制：
  > 由于 URL 长度的限制，GET 请求的参数传递大小有限制（通常为 2048 个字符），而 POST 请求的参数传递大小理论上没有限制（但实际上会受到服务器和客户端的限制）。
  >
  > 3. 数据传输方式：
  > GET 请求是幂等的，也就是说，对于同一个 URL，多次 GET 请求返回的结果是一样的，因此 GET 请求适合于数据的读取；而 POST 请求不是幂等的，也就是说，对于同一个 URL，多次 POST 请求可能会产生不同的结果，因此 POST 请求适合于数据的修改。
  >
  > 4. 缓存方式：
  > GET 请求会被浏览器缓存，因此会加快响应速度；而 POST 请求不能被浏览器缓存，因此响应速度相对较慢。
  >
  > 综上所述，GET 请求适合于数据的读取，数据量较小的情况，而 POST 请求适合于数据的修改，数据量较大的情况。

* (2)封装继承多态

* > 封装、继承和多态是Java中的三个重要的面向对象编程概念。
  >
  > 封装（Encapsulation）指的是将数据和方法进行包装，以实现信息的隐藏和保护，同时提高代码的可维护性和重用性。在Java中，封装通过访问修饰符（public、protected、private）来实现，可以通过getters和setters方法来访问封装的数据。
  >
  > 继承（Inheritance）指的是在已有的类基础上，派生出新的类，新类继承了原有类的属性和方法，并可以添加自己的属性和方法。继承可以提高代码的重用性和可扩展性，在Java中使用extends关键字实现继承。
  >
  > 多态（Polymorphism）指的是同一个方法可以在不同的对象上产生不同的行为，即一个方法可以具有多种不同的形式。Java中实现多态的方式有方法重载和方法重写，其中方法重载指的是在同一个类中，使用相同的方法名，但是参数类型、参数个数、参数顺序不同，而方法重写指的是在子类中重写父类的方法，实现不同的行为。

* (3)= =和equals区别

* > 在Java中，==和equals都是用于比较两个对象的方式，但它们的比较方式不同，其区别如下：
  >
  > ==：用于比较两个对象的引用是否指向同一个内存地址。如果两个对象的引用指向同一个内存地址，返回true，否则返回false。例如：
  >
  > ```
  > String str1 = "hello";
  > String str2 = "hello";
  > System.out.println(str1 == str2); //true，因为str1和str2指向同一个内存地址
  > ```
  > 注意：对于基本数据类型，==比较的是它们的值是否相等，而不是引用。
  >
  > equals：用于比较两个对象的内容是否相等。在Object类中，equals方法默认实现和==一样，即比较两个对象的引用是否相等。但是在许多Java类库中，如String、Integer、Double等类，它们重写了equals方法，使得它们比较的是对象的值是否相等。例如：
  > ```
  > String str1 = new String("hello");
  > String str2 = new String("hello");
  > System.out.println(str1.equals(str2)); //true，因为str1和str2的值相等
  > ```
  > 注意：如果想要自定义类支持equals方法比较对象的值，需要重写equals方法，并根据对象的属性值来判断是否相等。

* (4) &和&&的区别

* > 在Java中，&和&&都是逻辑运算符，但它们的作用有些不同，具体区别如下：
  >
  > &：表示按位与（Bitwise AND）运算符，用于对两个操作数的每一位执行逻辑与操作，返回一个新的整数。例如：
  > ```
  > int a = 3; //二进制表示为0011
  > int b = 5; //二进制表示为0101
  > int c = a & b; //执行按位与操作，得到0001，即1
  > ```
  > 同时，&也可以用于逻辑与（Logical AND）运算符，用于判断两个条件是否同时成立，返回一个布尔值。例如：
  > ```
  > int a = 3;
  > int b = 5;
  > if (a < 5 & b > 3) { //同时判断a是否小于5和b是否大于3
  >     //执行某些操作
  > }
  > ```
  > 注意：&逻辑运算符无论左右两边的表达式是否成立，都会执行两边的逻辑判断。
  >
  > &&：表示逻辑与（Logical AND）运算符，用于判断两个条件是否同时成立，返回一个布尔值。例如：
  > ```
  > int a = 3;
  > int b = 5;
  > if (a < 5 && b > 3) { //同时判断a是否小于5和b是否大于3
  >     //执行某些操作
  > }
  > ```
  > 注意：&&逻辑运算符只有左右两边的表达式都成立，才会执行右边的逻辑判断。
  >
  > 因此，&和&&的主要区别在于当左右两边的表达式都成立时，&会执行两边的逻辑判断，而&&只会执行右边的逻辑判断。在一些需要短路求值的情况下，&&会更常用，可以避免不必要的逻辑判断。

* (5) StringBuffer和StringBuilder区别

* > StringBuffer和StringBuilder都是Java中的字符串缓冲区类，它们都提供了可变的字符串序列。它们之间的主要区别如下：
  >
  > 1. 线程安全性：StringBuffer是线程安全的，因为它的方法都是同步的（synchronized修饰），可以在多线程环境下使用。而StringBuilder则不是线程安全的，因为它的方法都是非同步的。
  >
  > 2. 性能：由于StringBuffer的方法都是同步的，因此在单线程环境下，它的性能会比StringBuilder差。而StringBuilder的方法都是非同步的，因此在单线程环境下，它的性能会比StringBuffer好。
  >
  > 3. 应用场景：如果在多线程环境下需要进行字符串操作，建议使用StringBuffer，因为它是线程安全的。而在单线程环境下，如果需要进行大量字符串操作，建议使用StringBuilder，因为它的性能更好。
  >
  > 示例代码：
  > ```
  > StringBuffer sb = new StringBuffer(); //创建一个StringBuffer对象
  > sb.append("hello"); //在尾部添加字符串
  > sb.insert(0, "world"); //在指定位置插入字符串
  > System.out.println(sb.toString()); //输出结果为：worldhello
  > 
  > StringBuilder sb = new StringBuilder(); //创建一个StringBuilder对象
  > sb.append("hello"); //在尾部添加字符串
  > sb.insert(0, "world"); //在指定位置插入字符串
  > System.out.println(sb.toString()); //输出结果为：worldhello
  > ```
  > 总的来说，StringBuffer和StringBuilder都是可变的字符串序列，如果需要进行字符串操作，可以根据实际需要选择合适的类。如果在多线程环境下需要进行字符串操作，使用StringBuffer是更安全的选择。在单线程环境下，如果需要进行大量字符串操作，使用StringBuilder则更高效。

*  (6)重载和重写的区别

* > 在Java中，重载（Overload）和重写（Override）都是面向对象编程的基本概念，它们的区别如下：
  >
  > 1. 定义：重载指在同一个类中定义多个方法，它们的方法名相同，但是参数类型或个数不同。重写指在子类中重新定义父类中已经存在的方法，方法名和参数列表都必须与父类中的方法相同。
  >
  > 2. 实现：重载方法的实现是完全独立的，它们之间没有任何关系。重写方法必须在子类中重新实现父类中已经存在的方法，实现方式必须与父类中的方法签名（方法名、参数类型和个数）相同。
  >
  > 3. 调用：重载方法的调用是根据参数类型和个数的不同进行区分的，可以根据实参的类型和个数自动匹配合适的重载方法。重写方法的调用是在运行时动态绑定的，调用哪个方法取决于对象的实际类型。
  >
  > 4. 返回类型：重载方法的返回类型可以不同，但是不能只有返回类型不同而方法名和参数相同。重写方法的返回类型必须与父类中的方法返回类型相同或者是它的子类。
  >
  > 示例代码如下：
  > ```
  > //重载示例
  > public class OverloadDemo {
  >     public void print(int x) {
  >         System.out.println("int:" + x);
  >     }
  >     public void print(double x) {
  >         System.out.println("double:" + x);
  >     }
  >     public void print(String x) {
  >         System.out.println("String:" + x);
  >     }
  > }
  > 
  > //重写示例
  > public class OverrideDemo {
  >     public class Animal {
  >         public void move() {
  >             System.out.println("Animal move");
  >         }
  >     }
  >     public class Dog extends Animal {
  >         public void move() {
  >             System.out.println("Dog move");
  >         }
  >     }
  >     public static void main(String[] args) {
  >         Animal animal = new Animal();
  >         animal.move(); //输出结果为：Animal move
  > 
  >         Dog dog = new Dog();
  >         dog.move(); //输出结果为：Dog move
  > 
  >         Animal animal2 = new Dog();
  >         animal2.move(); //输出结果为：Dog move
  >     }
  > }
  > ```
  > 总的来说，重载和重写都是Java中的重要概念，它们分别适用于不同的场景，可以提高代码的可重用性和可读性。理解和掌握重载和重写的区别对于编写高质量的Java程序非常重要。

* (7)你用过哪些集合

* (8) list set map的区别

* > 在Java中，List、Set和Map是三种常见的集合类型，它们的主要区别如下：
  >
  > 1. List：List是一个有序的集合，它可以包含重复的元素。List允许通过索引来访问其中的元素，同时它也提供了一系列操作元素的方法，比如添加、删除、插入和替换等。List的实现类有ArrayList、LinkedList和Vector等。
  > 2. Set：Set是一个不允许重复元素的集合，它不保证元素的顺序，即Set中元素的顺序是无序的。Set提供了一些基本操作方法，比如添加、删除、查找和判断元素是否存在等。Set的实现类有HashSet、TreeSet和LinkedHashSet等。
  > 3. Map：Map是一种键值对的集合，它存储的是一组key-value的映射关系。Map中的key不能重复，每个key对应一个value。Map提供了一系列操作key和value的方法，比如添加、删除、查找和替换等。Map的实现类有HashMap、TreeMap和LinkedHashMap等。
  >
  > 示例代码如下：
  >
  > ```
  > //List示例
  > List<String> list = new ArrayList<>();
  > list.add("A");
  > list.add("B");
  > list.add("C");
  > list.add("B"); //List允许重复元素
  > System.out.println(list); //输出结果为：[A, B, C, B]
  > System.out.println(list.get(0)); //输出结果为：A
  > 
  > //Set示例
  > Set<String> set = new HashSet<>();
  > set.add("A");
  > set.add("B");
  > set.add("C");
  > set.add("B"); //Set不允许重复元素
  > System.out.println(set); //输出结果为：[A, B, C]
  > 
  > //Map示例
  > Map<String, Integer> map = new HashMap<>();
  > map.put("A", 1);
  > map.put("B", 2);
  > map.put("C", 3);
  > System.out.println(map); //输出结果为：{A=1, B=2, C=3}
  > System.out.println(map.get("B")); //输出结果为：2
  > ```
  >
  > 总的来说，List、Set和Map是Java中常用的集合类型，它们各自有不同的特点和用途。在实际开发中，根据具体的需求选择合适的集合类型，可以提高代码的效率和可维护性。

* (9) 你了解过什么线程安全的集合

* > 在Java中，线程安全的集合是为多线程环境设计的集合，它们具有良好的并发性能，能够保证在多线程环境下访问时的数据安全和一致性。常见的线程安全的集合包括：
  >
  > 1. ConcurrentHashMap：ConcurrentHashMap是线程安全的HashMap，它支持高并发访问。ConcurrentHashMap使用分段锁技术，将整个Map分成多个Segment，每个Segment上都有一把锁，不同的线程可以同时访问不同的Segment，从而提高并发性能。
  >
  > 2. CopyOnWriteArrayList：CopyOnWriteArrayList是线程安全的ArrayList，它使用了一种写时复制的机制，在对ArrayList进行修改操作时，会先将原始数组复制一份，然后进行修改操作。由于读取操作不需要加锁，因此读取操作的性能非常高，适合读多写少的场景。
  >
  > 3. ConcurrentLinkedQueue：ConcurrentLinkedQueue是线程安全的队列，它使用了无锁算法CAS（Compare and Swap）来实现并发访问。ConcurrentLinkedQueue是一个基于链表结构的队列，支持高并发的入队和出队操作。
  >
  > 4. BlockingQueue：BlockingQueue是一个阻塞队列，它可以自动地阻塞线程，直到队列中有元素或者队列中没有元素时被唤醒。BlockingQueue是一个接口，常见的实现类有ArrayBlockingQueue、LinkedBlockingQueue和PriorityBlockingQueue等。
  >
  > 除了上述几种线程安全的集合外，还有其他一些线程安全的集合，比如ConcurrentSkipListMap、ConcurrentSkipListSet和LinkedTransferQueue等，可以根据具体的需求进行选择。需要注意的是，在使用线程安全的集合时，虽然能够提高并发性能，但也会带来一些额外的开销，因此需要根据实际情况进行评估和选择。

* (10) 说一下hashmap的put原理， hashmap数组扩容为什么是2的n次方

* > HashMap是一种散列表（Hash Table）实现，它将键（Key）映射到值（Value），并使用键来快速访问值。HashMap的put操作是将一个键值对插入到HashMap中。
  >
  > HashMap的put操作的实现原理如下：
  >
  > 1. 首先，根据key的hashcode值计算出它在散列表中的位置（即在数组中的下标），如果这个位置上没有元素，就直接将key-value存储在这个位置上。
  >
  > 2. 如果这个位置上已经有元素了，那么就需要进行冲突处理，具体地，需要遍历这个位置上的元素链表，找到key值相同的元素，然后将其覆盖或者添加到链表的尾部。
  >
  > 3. 如果链表中的元素过多，会导致散列表的性能下降，因此当链表的长度超过一定的阈值（默认为8）时，会将链表转换成红黑树。
  >
  > 4. 如果红黑树的节点数小于等于6个，那么会将红黑树转换回链表。
  >
  > 5. 如果插入元素后，散列表中的元素数量超过了负载因子（默认为0.75），就会触发扩容操作，即将数组扩大一倍，并将所有元素重新分配到新的数组中。
  >
  > HashMap数组扩容为什么是2的n次方？这是因为在扩容操作中，HashMap会将元素重新计算hash值，新的hash值只会考虑数组的长度为2的n次方的部分，这样可以保证元素在扩容后能够均匀地分布在新的数组中，减少冲突的可能性。同时，由于在计算hash值时使用了位运算，使用2的n次方作为数组长度可以提高计算效率。

* (11) ArrayList和LinkedList的区别

* > ArrayList和LinkedList是Java集合框架中两种不同的List实现，它们之间的区别主要体现在以下几个方面：
  >
  > 1. 内部实现：ArrayList是基于数组实现的，而LinkedList是基于双向链表实现的。
  >
  > 2. 插入和删除操作的性能：由于ArrayList是基于数组实现的，插入和删除操作需要移动其他元素，因此在插入和删除操作时需要移动其他元素，而LinkedList是基于链表实现的，插入和删除操作只需要改变节点指针的指向，因此在插入和删除操作时性能更好。
  >
  > 3. 随机访问操作的性能：由于ArrayList是基于数组实现的，可以通过索引随机访问元素，而LinkedList是基于链表实现的，随机访问元素需要从头开始遍历链表，因此在随机访问操作时，ArrayList的性能更好。
  >
  > 4. 内存占用：由于ArrayList是基于数组实现的，它需要连续的内存空间来存储元素，因此在存储大量元素时会占用大量内存空间，而LinkedList是基于链表实现的，每个节点只需要存储元素和前后指针，因此在存储大量元素时相对较少占用内存空间。
  >
  > 综上所述，如果需要频繁进行插入和删除操作，使用LinkedList更加适合，而如果需要频繁进行随机访问操作，则使用ArrayList更加适合。同时，由于LinkedList相对较少占用内存空间，因此如果需要存储大量元素，可以考虑使用LinkedList。

*  (12) throw和throws的区别

* > 在Java中，throw和throws是两个关键字，它们用于异常处理，它们的区别如下：
  >
  > 1. throw关键字用于在代码块中抛出一个异常对象，用于表示程序出现了一个异常。当程序执行到throw语句时，程序立即终止，并将异常抛给调用者，调用者需要使用try-catch块或throws关键字来捕获这个异常。
  >
  > 2. throws关键字用于声明一个方法可能抛出的异常。在方法声明中使用throws关键字，告诉调用者该方法可能会抛出某些异常。如果调用者想要处理这些异常，则需要在调用方法时使用try-catch块或者继续使用throws关键字将异常继续抛给上层调用者。
  >
  > 总之，throw关键字用于在代码块中抛出异常，而throws关键字用于在方法声明中声明方法可能抛出的异常。throw用于主动抛出异常，而throws是用于告诉调用者可能会抛出哪些异常，需要调用者来处理这些异常。

* (13)接口和抽象类的区别

* > 在Java中，接口和抽象类都是用来实现多态性的机制，它们的主要区别如下：
  >
  > 1. 实现方式：接口是完全抽象的，只包含方法的声明和常量的定义，不包含方法的实现。抽象类则可以包含抽象方法和非抽象方法的实现，也可以包含字段。
  >
  > 2. 继承关系：一个类只能继承一个抽象类，但是可以实现多个接口。抽象类可以有构造方法，而接口不能有构造方法。
  >
  > 3. 访问修饰符：接口中的所有方法都是公共的（public），而抽象类中的方法可以有不同的访问修饰符。
  >
  > 4. 多态性：通过实现接口，类可以实现多个接口的多态性，而通过继承抽象类，类只能实现一个抽象类的多态性。
  >
  > 5. 设计目的：接口的设计目的是为了实现类的多态性，而抽象类的设计目的是为了代码复用。
  >
  > 综上所述，接口和抽象类都可以用来实现多态性，但是它们在实现方式、继承关系、访问修饰符、多态性和设计目的等方面都有不同。在实际应用中，需要根据具体的需求来选择使用接口还是抽象类。如果一个类需要实现多个类似的功能，可以使用接口，如果一个类需要实现一些基本功能并提供一些子类可以扩展的功能，可以使用抽象类。

* (14)要 去阿里巴巴开发规范手册上面看几个规范

#### java反射:

这个对1到2年经验的极为重要

* (1)3种创建class对象方式

* > 在Java中，可以使用以下三种方式创建Class对象：
  >
  > 1. 使用Class.forName()方法创建：这种方式是使用类的全限定名（包括包名和类名）作为参数，然后通过Class.forName()方法来加载这个类，并返回对应的Class对象。例如：
  >
  > ```java
  > Class<?> cls = Class.forName("com.example.MyClass");
  > ```
  >
  > 2. 使用类名.class创建：这种方式是在编译时就已经确定了Class对象，它是编译器自动生成的。例如：
  >
  > ```java
  > Class<?> cls = MyClass.class;
  > ```
  >
  > 3. 使用对象.getClass()方法创建：这种方式是在运行时根据对象来获取对应的Class对象，例如：
  >
  > ```java
  > MyClass obj = new MyClass();
  > Class<?> cls = obj.getClass();
  > ```
  >
  > 以上三种方式都可以创建Class对象，不同的是它们的应用场景不同。第一种方式适用于需要动态加载类的情况，第二种方式适用于已知类名的情况，第三种方式适用于已有对象需要获取对应Class对象的情况。

* (2)怎么通过反射创建一个对象

* > 通过反射可以创建任意一个类的对象，可以按照以下步骤来创建一个对象：
  >
  > 1. 获取对应的Class对象，有多种方式可以获取，例如使用Class.forName()方法、类名.class、对象.getClass()方法等。
  >
  > 2. 使用Class对象的newInstance()方法来创建对象，该方法会调用类的无参构造方法来创建对象。例如：
  >
  > ```java
  > Class<?> cls = Class.forName("com.example.MyClass");
  > Object obj = cls.newInstance();
  > ```
  >
  > 上述代码将创建一个com.example.MyClass的对象，其中newInstance()方法返回的是Object类型，需要强制转换为MyClass类型，例如：
  >
  > ```java
  > MyClass myObj = (MyClass)obj;
  > ```
  >
  > 如果类没有定义无参构造方法，则需要使用其他方式创建对象，例如使用Constructor类的newInstance()方法，该方法可以调用类的有参构造方法来创建对象。例如：
  >
  > ```java
  > Class<?> cls = Class.forName("com.example.MyClass");
  > Constructor<?> constructor = cls.getConstructor(String.class, int.class);
  > Object obj = constructor.newInstance("myString", 123);
  > MyClass myObj = (MyClass)obj;
  > ```
  >
  > 上述代码将使用MyClass类的带有一个String类型和一个int类型参数的构造方法来创建对象，并将"myString"和123作为参数传入构造方法。

* (3)反射的使用场景

* > 反射是Java的一种高级特性，它可以在运行时动态地获取和操作类的信息。反射提供了许多强大的功能，例如创建对象、获取和设置字段、调用方法、访问构造方法等。反射主要用于以下场景：
  >
  > 1. 动态创建对象：通过反射可以在运行时动态地创建任意一个类的对象，这种方式适用于需要动态地加载类或者根据用户输入的字符串来创建对象的情况。
  >
  > 2. 获取和设置字段：通过反射可以获取一个类的所有字段，并可以在运行时动态地读取或者修改它们的值。这种方式适用于需要在运行时根据需要动态地操作字段的情况。
  >
  > 3. 调用方法：通过反射可以获取一个类的所有方法，并可以在运行时动态地调用它们。这种方式适用于需要动态地调用不同方法或者根据用户输入的字符串来调用方法的情况。
  >
  > 4. 访问构造方法：通过反射可以获取一个类的所有构造方法，并可以在运行时动态地创建对象。这种方式适用于需要动态地根据不同参数创建对象的情况。
  >
  > 5. 注解处理：通过反射可以获取类、字段、方法等元素上的注解信息，并可以在运行时根据注解信息执行特定的逻辑。这种方式适用于需要根据注解信息来进行某些操作的情况。
  >
  > 总之，反射提供了一种动态地获取和操作类的信息的方式，它可以让程序更加灵活和可扩展。但是反射也有一些缺点，例如会降低程序的性能，而且容易导致代码可读性降低和安全性问题等，因此在使用反射时需要慎重考虑。

* (4)反射有什么优缺点

* > 反射是Java的一种高级特性，它可以在运行时动态地获取和操作类的信息。反射提供了许多强大的功能，例如创建对象、获取和设置字段、调用方法、访问构造方法等，使得程序具有更高的灵活性和可扩展性。但是，反射也存在一些优缺点。
  >
  > 反射的优点：
  >
  > 1. 动态性：通过反射可以在运行时动态地获取和操作类的信息，这种动态性可以使程序更加灵活和可扩展。
  >
  > 2. 通用性：反射可以用于任何一个类，不需要知道类的具体实现，只需要知道类的名字即可。
  >
  > 3. 便利性：反射可以使得代码更加简洁，例如可以通过反射来遍历一个类的所有字段或方法，从而避免了手动编写大量的代码。
  >
  > 反射的缺点：
  >
  > 1. 性能问题：反射会降低程序的性能，因为反射需要在运行时进行类型检查和方法调用，而这些操作比静态调用要慢。
  >
  > 2. 安全问题：反射可以访问和修改类的私有字段和方法，从而可能破坏程序的封装性和安全性。
  >
  > 3. 可读性问题：反射代码通常比静态代码更难理解和维护，因为反射代码需要在运行时才能确定其含义和正确性。
  >
  > 因此，在使用反射时需要权衡其优缺点，避免滥用反射，尽量使用静态代码来实现程序的功能。同时，在使用反射时需要注意安全问题，例如限制反射访问私有字段和方法的能力，从而保护程序的封装性和安全性。

io:这个不做要求，但是要记住几个常用的文件流的类

网络编程:不做要求

3.熟练掌握多线程编程，了解线程池的工作原理，并有实际的项目优化经验，(优化经验我会在 下期项目经验里面分享)

* 线程:

* > 线程池的工作原理
  >
  > 线程池是一种线程管理机制，它可以在应用程序启动时预先创建一定数量的线程，这些线程可以重复使用来执行多个任务，从而减少线程创建和销毁的开销，提高应用程序的性能。
  >
  > 线程池的工作原理可以分为如下几个步骤：
  >
  > 1. 创建线程池：在应用程序启动时，创建线程池对象，并设置线程池的大小、工作队列、拒绝策略等参数。
  >
  > 2. 提交任务：当应用程序需要执行一个任务时，将任务提交给线程池。
  >
  > 3. 执行任务：线程池从工作队列中获取一个任务，并将其分配给一个空闲的线程来执行。
  >
  > 4. 完成任务：线程执行完任务后，将任务执行结果返回给调用者，并将线程返回到线程池中。
  >
  > 5. 关闭线程池：当应用程序结束时，关闭线程池，释放线程资源。
  >
  > 线程池的优点包括：
  >
  > 1. 提高性能：线程池可以重复使用线程，减少线程的创建和销毁开销，提高应用程序的性能。
  >
  > 2. 提高稳定性：线程池可以控制线程的数量和资源消耗，从而避免因线程过多导致的内存溢出等问题。
  >
  > 3. 提高灵活性：线程池可以根据应用程序的需要，动态调整线程数量，从而适应不同的任务负载。
  >
  > 线程池的缺点包括：
  >
  > 1. 对资源的占用：线程池需要预先创建一定数量的线程，并占用一定的内存资源，这可能会对系统的性能和资源消耗造成一定的影响。
  >
  > 2. 任务等待的问题：当线程池中的所有线程都在执行任务时，新提交的任务将会被放入工作队列中等待，这可能会导致任务等待时间的增加。
  >
  > 总之，线程池在应用程序中有着广泛的应用，可以提高应用程序的性能和稳定性，但是需要根据实际情况合理配置线程池的参数，避免对系统造成不必要的影响。

* (1)线程和进程的区别

* > 线程和进程是计算机中的两个重要的概念，它们有以下几个区别：
  >
  > 1. 资源分配：进程是操作系统资源分配的基本单位，而线程是CPU调度的基本单位。
  >
  > 2. 独立性：进程之间是相互独立的，而线程不能单独存在，必须依附于进程。
  >
  > 3. 系统开销：进程之间的切换需要保存当前进程的状态信息，并加载下一个进程的状态信息，因此进程切换的系统开销比较大，而线程之间的切换只需要保存当前线程的上下文信息，因此线程切换的系统开销比较小。
  >
  > 4. 数据共享：进程之间的数据共享比较困难，通常需要采用进程间通信的方式，而线程之间可以共享同一个进程中的数据，因此线程之间的数据共享比较容易。
  >
  > 5. 调试和管理：由于进程之间是相互独立的，因此调试和管理比较困难，而线程之间可以共享同一个进程的调试和管理工具，因此调试和管理比较容易。
  >
  > 总之，进程和线程都是计算机中的重要概念，它们分别具有不同的特点和应用场景，我们需要根据实际需要来选择合适的方式来实现我们的需求。

* (2)线程有几种创建方式，有什么区别

* > 在Java中，线程有三种创建方式，分别是继承Thread类、实现Runnable接口和实现Callable接口。
  >
  > 1. 继承Thread类：创建线程最基本的方法是创建一个类，继承Thread类，并重写run()方法。在类中，创建Thread的实例并调用start()方法启动线程。这种方式的优点是简单，缺点是线程类和线程任务（run()方法）耦合性较高，不太灵活。
  >
  > 2. 实现Runnable接口：创建线程的第二种方法是实现Runnable接口。该接口只有一个run()方法，与第一种方式类似，需要创建Thread的实例并调用start()方法启动线程。这种方式的优点是可以避免Java单继承的限制，线程任务与线程类解耦，可以方便地共享资源，是Java中常用的创建线程的方式。
  >
  > 3. 实现Callable接口：Callable接口与Runnable接口相似，但是Callable接口可以返回一个值，并抛出异常。需要使用ExecutorService、Future和Callable来配合使用。该方式的优点是可以获取线程执行结果，并且可以抛出异常，缺点是相对于前两种方式，代码比较冗长。
  >
  > 总的来说，三种方式都可以创建线程，但使用Runnable接口可以避免Java单继承的限制，而使用Callable接口可以获取线程执行结果。在选择创建方式时，需要根据实际需求来选择合适的方式。

* (3)线程的几种状态

* > 在Java中，线程有以下几种状态：
  >
  > 1. 新建状态（New）：当通过创建Thread对象或其子类对象来创建线程时，线程处于新建状态。
  >
  > 2. 就绪状态（Runnable）：当线程被start()方法启动后，线程进入就绪状态，等待CPU调度。
  >
  > 3. 运行状态（Running）：当CPU开始调度线程时，线程进入运行状态，执行run()方法中的任务。
  >
  > 4. 阻塞状态（Blocked）：当线程在等待某个条件的满足时，会进入阻塞状态，例如调用sleep()方法、等待I/O操作、等待获取synchronized锁等。
  >
  > 5. 等待状态（Waiting）：当线程调用wait()方法、join()方法、park()方法等等时，线程进入等待状态。
  >
  > 6. 计时等待状态（Timed Waiting）：当线程调用sleep()方法、wait()方法指定等待时间、join()方法指定等待时间、parkNanos()方法等等时，线程进入计时等待状态。
  >
  > 7. 终止状态（Terminated）：当线程执行完run()方法或抛出异常时，线程进入终止状态。
  >
  > 线程的状态转换如下所示：
  >
  > New -> Runnable -> Running -> (Blocked, Waiting, Timed Waiting) -> Runnable -> Terminated
  >
  > 需要注意的是，线程的状态并不是按照上述的顺序依次转换的，线程的状态转换是由操作系统和CPU进行调度的，这取决于操作系统和CPU的具体实现。

#### 线程池

* (1)7大参数

* > Java中的线程池有七个参数，它们分别是：
  >
  > 1. corePoolSize：线程池的核心线程数，即线程池中最少存在的线程数。
  >
  > 2. maximumPoolSize：线程池的最大线程数，即线程池中最多存在的线程数。
  >
  > 3. keepAliveTime：线程池中空闲线程的存活时间，当线程池中的线程数大于corePoolSize时，如果这些线程处于空闲状态超过了keepAliveTime的时间，那么这些线程就会被销毁，直到线程池中的线程数不大于corePoolSize。
  >
  > 4. unit：keepAliveTime参数的时间单位，如TimeUnit.SECONDS。
  >
  > 5. workQueue：线程池中任务队列，用于存储还未执行的任务，它有多种实现方式，如ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue等。
  >
  > 6. threadFactory：线程工厂，用于创建新的线程，默认使用Executors.defaultThreadFactory()方法创建线程。
  >
  > 7. handler：当线程池中的线程数达到最大值并且队列也已经满了的情况下，新提交的任务的处理策略，有四种策略可选：ThreadPoolExecutor.AbortPolicy（抛出RejectedExecutionException异常）、ThreadPoolExecutor.DiscardPolicy（直接丢弃任务）、ThreadPoolExecutor.DiscardOldestPolicy（丢弃最老的任务，尝试将当前任务加入队列）、ThreadPoolExecutor.CallerRunsPolicy（由提交任务的线程来执行任务）。
  >
  > 其中，前五个参数是必须指定的，后两个参数是可选的，默认值分别为Executors.defaultThreadFactory()和ThreadPoolExecutor.AbortPolicy。

* (2)工作原理

* (3) 阻塞队列有哪些，拒绝策略有哪些，之间区别

* > Java中常用的阻塞队列有以下几种：
  >
  > 1. ArrayBlockingQueue：一个基于数组实现的有界阻塞队列，在队列满时会阻塞写入操作，队列空时会阻塞读取操作。
  >
  > 2. LinkedBlockingQueue：一个基于链表实现的无界阻塞队列，可以选择容量大小，如果没有指定，默认大小为Integer.MAX_VALUE。在队列满时会阻塞写入操作，队列空时会阻塞读取操作。
  >
  > 3. SynchronousQueue：一个没有缓冲的阻塞队列，在这种队列中，每个插入操作必须等待另一个线程的移除操作，反之亦然。即使队列中存在多个空闲线程，也不会保留任何元素。
  >
  > 4. PriorityBlockingQueue：一个支持优先级的无界阻塞队列，元素按照优先级顺序出队列，而不是按照进入队列的顺序出队列。
  >
  > 常见的拒绝策略有以下几种：
  >
  > 1. ThreadPoolExecutor.AbortPolicy：直接抛出异常，阻止系统正常运行。
  >
  > 2. ThreadPoolExecutor.DiscardPolicy：默默地丢弃无法处理的任务，不予任何处理。
  >
  > 3. ThreadPoolExecutor.DiscardOldestPolicy：丢弃最老的任务（即队列中最前面的任务），尝试再次提交当前任务。
  >
  > 4. ThreadPoolExecutor.CallerRunsPolicy：由提交任务的线程来执行任务。
  >
  > 以上阻塞队列和拒绝策略的选择取决于具体的业务场景和需求。比如，如果需要一个有界队列，在任务到达队列尾部时将会阻塞，可以选择使用ArrayBlockingQueue；如果需要一个无界队列，在任务到达队列尾部时不会阻塞，可以选择使用LinkedBlockingQueue；如果需要一个优先级队列，可以选择PriorityBlockingQueue。而拒绝策略的选择也取决于具体的业务需求，例如需要丢弃最老的任务，可以选择使用ThreadPoolExecutor.DiscardOldestPolicy策略。

* (3)线程池submit和execute方法区别

* > 在Java线程池中，submit()和execute()方法都用于提交任务到线程池中执行，它们的区别如下：
  >
  > 1. 返回值不同：execute()方法没有返回值，submit()方法返回一个Future对象，用于表示任务的状态和返回值。
  >
  > 2. 异常处理不同：当任务抛出异常时，execute()方法无法捕获并处理异常，而submit()方法可以通过Future对象的get()方法来获取任务抛出的异常，并进行处理。
  >
  > 3. 接收参数不同：execute()方法只能接收Runnable对象，而submit()方法可以接收Runnable和Callable对象。
  >
  > 4. 任务处理顺序不同：execute()方法的任务处理是按照FIFO的顺序进行处理，即先进先出；而submit()方法的任务处理顺序则是不确定的，取决于底层线程池的具体实现方式。
  >
  > 总的来说，如果你需要获取任务的执行结果或者捕获任务的异常，那么建议使用submit()方法；如果你只需要提交任务并执行，不关心任务的返回结果和异常处理，那么可以使用execute()方法。

* (4)shutdown()和shutdownNow()区别

* > 在Java线程池中，shutdown()和shutdownNow()都是用于关闭线程池的方法，它们的区别如下：
  >
  > 1. shutdown()方法是平缓地关闭线程池，即该方法会等待线程池中的所有任务都执行完毕之后再关闭线程池，不会接受新的任务提交。而shutdownNow()方法则是立即关闭线程池，该方法会尝试停止所有正在执行的任务，并且不再处理等待队列中的任务。
  >
  > 2. shutdown()方法返回void类型，而shutdownNow()方法返回一个List类型的未完成任务列表，这些任务包括等待队列中的和正在执行的任务。
  >
  > 3. shutdown()方法不会中断正在执行的任务，只会让线程池进入关闭状态，而shutdownNow()方法会中断正在执行的任务，即使任务还未执行完毕。
  >
  > 因此，如果你想平缓地关闭线程池，让线程池中的任务都得到执行，并且不再接受新的任务提交，那么可以使用shutdown()方法；如果你想立即关闭线程池，不再处理等待队列中的任务，并且中断正在执行的任务，那么可以使用shutdownNow()方法。

* (5)你们公司使用的是哪种线程池，参数怎么设置的，有什么依据(这个可不了解，比较难)。

* (6)能不能直接使用Executors自带的线程池， 为什么

* > 在Java中，可以使用Executors类提供的线程池工厂方法来创建线程池，例如newFixedThreadPool、newCachedThreadPool等等。这些线程池都是可用的，并且提供了一些方便的方法，例如submit和shutdown等等。但是，建议在实际开发中避免直接使用Executors自带的线程池，主要有以下原因：
  >
  > 1. 线程池大小不可控：Executors提供的线程池工厂方法都是固定的，不能满足不同应用场景下的线程池大小需求，因此可能会出现线程池过大或过小的情况。
  >
  > 2. 队列容量有限：线程池中的任务需要先进入等待队列，而等待队列的容量是有限制的，当等待队列已满时，线程池会拒绝新的任务提交。但是，Executors提供的线程池工厂方法中，等待队列的容量是固定的，并且是没有上限的，这可能会导致内存溢出等问题。
  >
  > 3. 线程池参数不可调：Executors提供的线程池工厂方法中，线程池参数是固定的，例如线程池大小、等待队列容量等等，无法进行调整和优化。
  >
  > 综上所述，建议在实际开发中，根据应用场景和需求，自定义线程池，并且根据实际情况进行参数的调整和优化，以提高线程池的效率和性能。

4.熟练掌握Mysql数据库，对mysq|事务，sq|调优， 索引有一定了解

#### 事务: 

* (1)事务的特性

* > 在关系型数据库中，事务是指一组要么全部执行成功，要么全部不执行的数据库操作。事务具有以下四个特性（ACID特性）：
  >
  > 1. 原子性（Atomicity）：事务是一个原子操作，要么全部执行，要么全部不执行，不能部分执行，要么全部成功，要么全部失败。如果事务在执行过程中发生了错误，那么所有的操作都会被回滚，恢复到事务执行前的状态。
  >
  > 2. 一致性（Consistency）：在事务开始和结束时，数据库必须保持一致性状态。事务执行的结果必须满足数据库的约束和完整性规则。
  >
  > 3. 隔离性（Isolation）：事务之间必须互相隔离，每个事务都应该感觉不到其他事务的存在。在并发环境下，多个事务可以同时执行，但是必须保证各个事务之间相互隔离，不能互相干扰。
  >
  > 4. 持久性（Durability）：一旦事务提交，其结果就应该永久保存在数据库中，即使系统发生故障，也不能丢失提交的数据。
  >
  > 这四个特性保证了事务的可靠性、一致性和可恢复性，是数据库管理系统中非常重要的基础功能。事务可以通过编程方式或者SQL语句来实现，具体实现方式和语法会因不同的数据库而有所不同。

* (2)事务的隔离级别

* > 在数据库中，事务隔离级别是指多个事务之间相互隔离的程度。由于多个事务可能并发执行，如果不采取一定的隔离措施，就可能出现一些不可预期的结果。数据库规定了四种事务隔离级别，从低到高依次为：
  >
  > 1. 读未提交（Read Uncommitted）：最低的隔离级别，允许一个事务读取另一个事务尚未提交的数据。这种隔离级别可能导致脏读（Dirty Read），即一个事务读取到了其他事务尚未提交的数据，后续这些数据可能被回滚，导致读取到的数据是错误的。
  >
  > 2. 读已提交（Read Committed）：一个事务只能读取另一个事务已经提交的数据，这样可以避免脏读。但是，由于其他事务正在执行，因此读取到的数据可能是其他事务修改过的，而不是最新的数据。这种隔离级别可能导致不可重复读（Non-Repeatable Read），即在同一个事务内，多次读取同一个数据，但是得到的结果不一样。
  >
  > 3. 可重复读（Repeatable Read）：在同一个事务内，多次读取同一个数据得到的结果是一样的，不会出现不可重复读。为了实现这个隔离级别，数据库会对读取的数据加锁，避免其他事务对其进行修改。
  >
  > 4. 序列化（Serializable）：最高的隔离级别，要求所有事务依次执行，不能并发执行。这种隔离级别可以避免幻读（Phantom Read），即一个事务多次执行同一个查询，但是得到的结果不一样。
  >
  > 隔离级别越高，数据一致性就越好，但是对系统的性能会有一定的影响。因此，在选择隔离级别时，需要根据具体的业务场景和系统需求来确定。

* (3)事务的传播行为(记两种即可，required和required new的区别) 

* > 事务的传播行为是指在多个事务方法互相调用时，不同方法之间事务如何进行传播和合并。
  >
  > `REQUIRED`：默认传播行为，如果当前存在事务，则加入该事务，否则新建一个事务。如果当前事务已经结束（被提交或者回滚），则新的事务重新启动。
  >
  > `REQUIRES_NEW`：每次调用该方法都会新建一个独立的事务，该方法的事务会被独立提交或者回滚，并且当前方法不会受到调用方事务的影响。
  >
  > 下面是 `REQUIRED` 和 `REQUIRES_NEW` 的区别：
  >
  > - 当方法 A（事务传播行为为 `REQUIRED`）调用方法 B（事务传播行为为 `REQUIRES_NEW`）时，B 方法会开启一个新的事务，A 方法会挂起事务并等待 B 方法事务完成后继续执行 A 方法的事务；
  > - 当方法 A（事务传播行为为 `REQUIRED`）调用方法 B（事务传播行为为 `REQUIRED`）时，B 方法将加入 A 方法的事务，与 A 方法共用同一个事务，如果 B 方法回滚，A 方法也将回滚。
  >
  > 简单来说，`REQUIRED` 和 `REQUIRES_NEW` 的区别在于是否开启新的事务，如果需要在一个方法中独立处理一个事务，则应该选择 `REQUIRES_NEW`，否则应该选择默认的 `REQUIRED`。

* (4) mysql默认的隔离级别

* > MySQL 默认的隔离级别是 `REPEATABLE READ`，它是一种比较严格的隔离级别。在这个级别下，同一事务中的查询会读取到相同的快照数据，因此可以重复读取相同的结果，不会受到其他事务的干扰。但是，由于它需要对事务期间所有读取的数据进行加锁，因此可能会导致大量的锁竞争，进而影响性能。如果应用程序的并发性要求不高，可以使用默认的 `REPEATABLE READ` 隔离级别；否则，可以根据业务需求适当调整隔离级别。

(5)能针对两个事务在不同的隔离级别下进行一些curd后还能说的清楚会发生什么问题

sql调优:记一个流程即可， 知道explain关键字

#### 索引:

* (1)b树和b+树的区别

* > B树和B+树都是常见的多路搜索树，主要应用于文件系统和数据库系统中。
  >
  > 它们的主要区别如下：
  >
  > 1. 数据节点和索引节点的结构不同：
  >
  > 在B树中，每个节点不仅可以存储关键字，还可以存储对应的数据记录。这意味着，B树的非叶子节点和叶子节点的结构是一样的。
  >
  > 在B+树中，非叶子节点只存储关键字，不存储数据记录，而所有的数据记录都保存在叶子节点中。这意味着，B+树的叶子节点是存储数据的节点，而非叶子节点仅仅是用来索引的节点。
  >
  > 2. 每个节点能存储的关键字数量不同：
  >
  > 在B树中，每个节点能存储的关键字数量通常比B+树要多。这是因为B树的非叶子节点和叶子节点都可以存储关键字和数据记录，而B+树的非叶子节点只存储关键字，所以需要更多的节点才能存储同样数量的数据。
  >
  > 3. 遍历方式不同：
  >
  > 在B树中，由于每个节点都包含数据记录，因此可以通过在非叶子节点中查找关键字来遍历整棵树。
  >
  > 在B+树中，由于非叶子节点不包含数据记录，因此必须遍历叶子节点来查找数据记录。而且，B+树的叶子节点是通过指针链接在一起的，可以按照顺序遍历整棵树。
  >
  > 4. 数据查询方式不同：
  >
  > 在B树中，由于数据记录存储在非叶子节点和叶子节点中，因此可以通过在非叶子节点中查找关键字来查询数据记录。
  >
  > 在B+树中，由于非叶子节点不包含数据记录，因此必须遍历叶子节点来查找数据记录。
  >
  > 综上所述，B树和B+树虽然都是多路搜索树，但它们在节点结构、每个节点能存储的关键字数量、遍历方式和数据查询方式等方面存在很大的差异。B+树相对于B树来说，在查找效率、范围查询、排序等方面有很大的优势，因此在数据库系统中得到广泛应用。

* (2)索引失效情况

* > 在数据库中，索引是一种数据结构，可以提高查询的效率。但是，在某些情况下，索引可能会失效，导致查询变慢或者不走索引。以下是一些常见的索引失效情况：
  >
  > 1. 对索引列进行了函数操作：如果对索引列进行了函数操作，例如使用了函数、表达式或者类型转换，那么该索引就会失效，因为索引只能在索引列上进行匹配。
  >
  > 2. 对索引列进行了计算或者运算：如果在查询条件中对索引列进行了计算或者运算，那么索引也会失效。例如，在 WHERE 子句中使用了 BETWEEN、IN、LIKE 等操作符，就可能会导致索引失效。
  >
  > 3. 使用了不等于操作符（<>、!=）：如果在 WHERE 子句中使用了不等于操作符（<>、!=），那么索引就会失效。因为索引只能用于匹配相等的值，不能用于匹配不等的值。
  >
  > 4. 数据量过小：如果数据量很小，那么 MySQL 就可能会选择不使用索引，因为扫描整张表可能比使用索引更快。
  >
  > 5. 索引列上存在 NULL 值：如果索引列上存在 NULL 值，那么 MySQL 在查询时就无法使用索引。
  >
  > 6. 索引列不是查询条件的最左前缀：如果索引列不是查询条件的最左前缀，那么索引也会失效。例如，如果有一个联合索引（a, b），那么在查询条件中只使用了 b，而没有使用 a，那么索引就会失效。
  >
  > 7. 对字符串进行了排序或者比较：如果在 ORDER BY 或者 GROUP BY 子句中对字符串进行了排序或者比较，那么索引也会失效。因为 MySQL 在排序或者比较字符串时，会使用字符串的整个值，而不是索引的部分值。

* (3)建立索引有什么依据

* > 建立索引的依据主要有以下几个方面：
  >
  > 1. 频繁作为查询条件的字段应该建立索引。比如说在 WHERE 子句中经常使用的字段，如主键、外键、经常用于查询、排序和分组的字段等。
  >
  > 2. 数据重复度低的字段建立索引的效果会更好。比如说性别、是否等字段就不适合建立索引，因为这些字段的值大部分都相同。
  >
  > 3. 数据量大的表需要建立索引。一般情况下，数据量少的表查询速度本来就快，即使不建立索引也不会影响查询效率。但是，当数据量变得非常大时，查询速度就会明显降低，建立索引就会变得尤为重要。
  >
  > 4. 不建议对过多字段建立联合索引。虽然建立联合索引可以提高查询效率，但是过多的联合索引也会占用大量的磁盘空间，而且在插入、删除、修改数据时也会变得很慢，因此应该适当把握联合索引的数量。
  >
  > 5. 应该选择适当的索引类型。在建立索引时，应该根据具体的业务需求选择适当的索引类型。比如说，单列索引适用于对单个列进行查询，而组合索引适用于对多个列进行查询。此外，全文索引适用于对文本类型的数据进行查询。
  >
  > 总之，在建立索引时，需要根据具体的业务需求和数据特点来选择适当的索引类型和建立索引的字段，以达到最优的查询性能。

* (4)MySql最多创建多少个索引

* > 在MySQL中，表可以创建的索引数量是有限制的。具体的限制取决于数据库引擎和操作系统。对于InnoDB引擎，可以创建的索引数量是64个，其中包括主键索引和辅助索引。而对于MyISAM引擎，可以创建的索引数量是不限制的，但是其它因素，如操作系统和可用内存等，也会影响实际可以创建的索引数量。

5.熟练掌握Spring、SpringMVC、 MyBatis, 并有实际的项目开发经验

#### spring: 

* (1)什么是aop,ioc

* > AOP和IOC是两个常见的面向对象编程中的设计模式。
  >
  > AOP（Aspect Oriented Programming，面向切面编程）是一种编程范式，它通过将横切关注点（如日志记录、性能统计、安全控制等）与核心业务逻辑分离开来，从而提高代码的可重用性和可维护性。
  >
  > IOC（Inversion of Control，控制反转）是一种设计原则，它通过将对象的创建、组装和管理过程交给容器来实现，从而实现对象之间的松耦合和可重用性。
  >
  > 在实际应用中，通常会将AOP和IOC结合起来使用，以实现更加灵活和可扩展的应用程序。例如，在Spring框架中，AOP和IOC被广泛应用于开发Web应用、企业级应用、分布式应用等各种场景。

* (2)ioc好处

* > IOC（Inversion of Control，控制反转）是一种设计原则，它通过将对象的创建、组装和管理过程交给容器来实现，从而实现对象之间的松耦合和可重用性。IOC有以下几个好处：
  >
  > 1. 降低组件之间的耦合度：在传统的编程模式中，组件之间的耦合度比较高，修改一个组件的实现可能会影响到其它组件的实现。而采用IOC容器管理对象的方式，组件之间的耦合度可以大大降低，使得每个组件都可以独立地开发、测试和部署。
  >
  > 2. 提高代码的可重用性：使用IOC容器可以将组件的创建和配置过程抽象出来，使得组件可以被多个模块和应用程序共享和重用，提高了代码的可重用性。
  >
  > 3. 简化配置和部署过程：使用IOC容器可以将组件的创建和配置过程集中在一个地方，使得组件的配置和部署过程变得简单和快速，减少了出错的可能性。
  >
  > 4. 实现面向接口编程：使用IOC容器可以将组件的实现和接口分离开来，使得程序的设计更加符合面向对象编程的原则，提高了代码的可维护性和可扩展性。
  >
  > 总之，IOC的好处包括降低耦合度、提高代码重用性、简化配置和部署过程、实现面向接口编程等，它是现代软件开发中的一个重要技术。

* (3)aop几种动态代理方式，有什么区别，默认是什么动态代理

* > 在 AOP 中，常用的动态代理方式有两种：基于接口的 JDK 动态代理和基于类的 CGLIB 动态代理。
  >
  > JDK 动态代理只能对实现了接口的类生成代理，而不能针对类。CGLIB 是针对类实现代理的，它的原理是对指定的类生成一个子类，并覆盖其中的方法实现增强。
  >
  > JDK 动态代理是 Java 自带的动态代理方式，在运行时，通过 Java 反射机制生成代理类。而 CGLIB 动态代理是通过继承实现的代理方式，在运行时，CGLIB 会动态生成一个被代理类的子类，通过方法拦截技术拦截所有父类方法的调用，并顺带进行增强。
  >
  > 在 Spring 框架中，默认使用 JDK 动态代理，只有当 Bean 没有实现接口时，才会使用 CGLIB 动态代理。因为 CGLIB 动态代理比 JDK 动态代理效率低，并且在某些情况下可能会出现内存溢出的情况。

* (4)哪些地方你用到过aop

* > AOP 可以用来实现一些横切关注点的功能，例如日志记录、性能统计、安全控制、事务处理等。在实际项目中，我可以用 AOP 实现日志记录功能，通过拦截方法调用来记录方法的入参、出参以及执行时间等信息，方便系统的监控和维护。还可以通过 AOP 实现权限控制功能，通过拦截方法调用来进行用户权限的验证，确保只有有权限的用户才能访问相应的资源。在 Spring 框架中，事务管理是 AOP 的一个常见应用场景，通过拦截方法调用来实现事务的控制，确保数据的一致性和完整性。
  >
  > 除了以上常见应用场景，AOP 还可以用于实现一些非业务功能的横切关注点，例如缓存、异常处理等。例如在方法调用时，可以使用 AOP 进行缓存判断，如果缓存中已经存在相应的数据，则直接返回缓存数据，否则再执行方法调用来获取数据。

* (5)@Autowired和@Resouce的区别

* > 在Spring框架中，`@Autowired`和`@Resource`注解都可以用于自动装配Bean。它们的主要区别在于：
  >
  > 1. `@Autowired`是Spring提供的注解，而`@Resource`是Java EE提供的注解，需要引入`javax.annotation`包。
  > 2. `@Autowired`是根据类型（byType）自动装配，`@Resource`是根据名称（byName）自动装配。如果多个Bean的类型相同，使用`@Autowired`时必须指定特定的Bean名称或限定符。
  > 3. `@Autowired`支持可选项(required=false)，表示如果找不到匹配的Bean，则允许该字段为null，`@Resource`不支持可选项，找不到匹配的Bean时会抛出异常。
  > 4. `@Autowired`只能用于字段、构造函数和方法，`@Resource`可以用于字段、构造函数、方法以及Bean属性的setter方法。
  >
  > 因此，当Bean名称比较重要且需要进行明确指定时，应该使用`@Resource`注解；否则，可以使用`@Autowired`注解。

* (6)bean的作用域有哪些

* > 在 Spring 中，bean 的作用域定义了一个 bean 的实例在容器中的生命周期及可见范围。常用的作用域包括：
  >
  > 1. singleton：单例模式，一个 Spring 容器只存在一个 bean 的实例对象，默认作用域。
  > 2. prototype：原型模式，每次从容器中获取该 bean 时，都会创建一个新的实例对象。
  > 3. request：请求作用域，每个 HTTP 请求都会创建一个新的实例对象，仅适用于 Web 应用。
  > 4. session：会话作用域，每个 HTTP 会话都会创建一个新的实例对象，仅适用于 Web 应用。
  > 5. global-session：全局会话作用域，基于 Portlet 应用的 Web 应用环境，如果使用 Portlet，则可以使用该作用域。
  >
  > 需要注意的是，不同的作用域对应着不同的实例创建策略，因此在选择 bean 的作用域时需要根据实际需求进行选择。例如，如果一个 bean 的实例需要被多次使用，那么可以使用 singleton 作用域，如果一个 bean 的实例需要每次都是新的，那么可以使用 prototype 作用域。

* (7) spring自动装配方式有几种，各有什么区别

* > Spring自动装配的方式有三种：
  >
  > 1. byName自动装配：Spring容器在初始化时，会自动将与bean的id同名的bean属性自动装配到该bean中。需要在XML文件中使用 `autowire="byName"` 属性开启byName自动装配。
  >
  > 2. byType自动装配：Spring容器会自动将该bean所依赖的类型与Spring容器中的bean类型进行匹配，然后将匹配的bean自动装配到该bean中。需要在XML文件中使用 `autowire="byType"` 属性开启byType自动装配。
  >
  > 3. constructor自动装配：Spring容器会自动将该bean所依赖的构造函数参数与Spring容器中的bean类型进行匹配，然后将匹配的bean自动注入到该bean中。需要在XML文件中使用 `autowire="constructor"` 属性开启constructor自动装配。
  >
  > 其中，byName和byType自动装配是根据bean属性的名称或类型进行自动匹配，而constructor自动装配则是根据构造函数的参数类型进行自动匹配。
  >
  > 需要注意的是，使用自动装配时需要保证bean的id或类型是唯一的，否则会出现装配错误的情况。同时，自动装配也有可能导致不必要的依赖关系和歧义，因此在使用时需要谨慎考虑。

* (8) spring事务注解里面的一些参数设置，spring默认的事务隔离级别是什么

* > Spring事务注解里面的一些参数设置包括：
  >
  > 1. `propagation`：事务传播行为，默认为 `Propagation.REQUIRED`，表示有事务就加入事务，没有就新建一个事务。
  > 2. `isolation`：事务隔离级别，默认为 `Isolation.DEFAULT`，表示使用数据库默认隔离级别。
  > 3. `timeout`：事务超时时间，默认为 -1，表示没有超时限制。
  > 4. `readOnly`：事务是否只读，默认为 false，表示可以读写。
  > 5. `rollbackFor`：触发事务回滚的异常类型，默认为空，表示遇到任何异常都回滚。
  > 6. `noRollbackFor`：不触发事务回滚的异常类型，默认为空，表示遇到任何异常都回滚。
  >
  > Spring默认的事务隔离级别是数据库的默认隔离级别。可以通过设置 `isolation` 属性来指定事务的隔离级别。

#### SpringMVC: 

* (1)请求流程

* > 1. 客户端发送请求到DispatcherServlet（前端控制器）。
  > 2. DispatcherServlet 根据请求信息调用 HandlerMapping（处理器映射器）查找 Handler（处理器）。
  > 3. HandlerMapping 返回 Handler 及其相关的 HandlerAdapter（处理器适配器），DispatcherServlet 调用 HandlerAdapter。
  > 4. HandlerAdapter 经过适配调用真正的处理器（Controller，也叫后端控制器）。
  > 5. Controller 执行完成后返回 ModelAndView。
  > 6. HandlerAdapter 将 Controller 返回的 ModelAndView 返回给 DispatcherServlet。
  > 7. DispatcherServlet 将返回的 ModelAndView 传给 ViewResolver（视图解析器）。
  > 8. ViewResolver 解析 ModelAndView 返回具体的 View（视图）。
  > 9. DispatcherServlet 将 View 返回给客户端。
  >
  > 简而言之，请求首先由 DispatcherServlet 进行接收并进行请求分发，然后 HandlerMapping 负责根据请求信息查找处理器，并返回相应的处理器及其适配器，HandlerAdapter 负责适配并调用真正的处理器，Controller 进行处理后返回 ModelAndView，最后由 ViewResolver 解析并返回视图。

#### mybatis:

* (1)#{}和${}区别(高频问题) 

* > 在 MyBatis 中，`#{}`和`${}`是两种不同的参数占位符。
  >
  > `#{}`是预编译语句（prepared statement）的参数占位符，它的作用是将传入的参数进行占位符替换，并对传入的参数进行安全性检查和防止 SQL 注入攻击等处理。例如：
  >
  > ```xml
  > <select id="getUserById" resultType="User">
  >   SELECT * FROM users WHERE id = #{id}
  > </select>
  > ```
  >
  > 在执行这个 SQL 时，`#{id}` 会被替换成实际传入的参数，并在替换时使用了预编译语句来保证安全性。
  >
  > 相比之下，`${}`是直接替换 SQL 字符串中的变量占位符。例如：
  >
  > ```xml
  > <select id="getUserByName" resultType="User">
  >   SELECT * FROM users WHERE name = '${name}'
  > </select>
  > ```
  >
  > 在执行这个 SQL 时，`${name}` 会被直接替换成传入的参数的值，这种方式可能会存在安全性问题，因为无法保证传入的参数是安全的，容易受到 SQL 注入攻击等风险。
  >
  > 因此，推荐在 MyBatis 中使用 `#{}` 占位符来处理参数。

* (2) 当实体类和表字段不一样怎么处理

* > 当实体类和表字段不一致时，可以使用 MyBatis 的注解来进行处理，比如：
  >
  > 1. @Result 注解：可以指定查询结果集中列名和 Java 对象属性名的映射关系，例如：
  >    ```
  >    @Result(column="user_name", property="userName")
  >    ```
  > 2. @Results 注解：可以用于配置多个 @Result 注解，例如：
  >    ```
  >    @Results({
  >      @Result(column="user_name", property="userName"),
  >      @Result(column="user_age", property="userAge")
  >    })
  >    ```
  > 3. @Param 注解：可以指定 SQL 参数名称，例如：
  >    ```
  >    @Select("SELECT * FROM user WHERE user_name = #{name}")
  >    User getUserByName(@Param("name") String name);
  >    ```
  >    在 SQL 中可以使用 `#{name}` 来引用参数名称。
  >
  > 这些注解都是 MyBatis 提供的解决实体类和表字段不一致的方式。

* (3) Mybatis中Xml文件id是否能重复

* > Mybatis中的XML文件id是全局唯一的，不能重复。在一个Mapper XML文件中，所有的SQL语句的id必须唯一。但是在不同的Mapper XML文件中，可以存在相同的id。如果出现相同的id，Mybatis会抛出异常并终止加载Mapper XML文件的过程。因此，为了避免这种情况，我们应该为每个SQL语句赋予唯一的id。

* (4)mybatis 1级缓存和2级缓存是什么，区别，如何开启二级缓存

* > MyBatis中的缓存分为一级缓存和二级缓存。
  >
  > 一级缓存指的是MyBatis中SqlSession的缓存。当我们执行某个查询时，MyBatis会先去SqlSession的缓存中查找是否有对应的结果，如果有就直接返回缓存中的结果，如果没有就去数据库中查询。一级缓存的生命周期和SqlSession一样长，当SqlSession关闭时，缓存也会被清空。
  >
  > 二级缓存是指Mapper级别的缓存。它可以跨SqlSession存在，当不同的SqlSession执行同一个Mapper中的查询时，会先从二级缓存中查找是否有对应的结果，如果有就直接返回缓存中的结果，如果没有就去数据库中查询。二级缓存需要开启才能使用，可以在Mapper.xml中配置cache节点开启二级缓存。需要注意的是，开启了二级缓存并不意味着所有查询都会被缓存，只有在Mapper.xml中显式指定使用缓存的查询才会被缓存。
  >
  > 使用一级缓存是MyBatis的默认行为，不需要额外的配置。而要开启二级缓存，需要在Mapper.xml文件中的cache节点中进行配置，例如：
  >
  > ```xml
  > <cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
  > ```
  >
  > 上面的配置开启了使用Ehcache作为二级缓存。需要注意的是，使用二级缓存可能会引起数据不一致的问题，因此在使用二级缓存时需要仔细考虑缓存的策略和刷新机制。

6.熟练掌握SpringBoot框架，了解其自动配置原理

#### springboot:

* (1)自动装配的过程

* > Spring Boot 自动装配（Auto-configuration）的原理主要涉及以下两个核心机制：
  >
  > 1. Spring Boot Starter机制： Spring Boot Starter 是一个 Maven 依赖项集合，它提供了特定功能的依赖项，这些依赖项可以一次性添加到项目中。 Starter 会自动配置 Spring 应用程序上下文，从而使得这些依赖项可以自动集成到项目中。
  >
  > 2. Spring Boot 的条件注解机制：Spring Boot 通过条件注解机制来实现自动配置的选择性注入。条件注解是基于条件判断的机制，可以根据不同的条件来判断是否需要创建某个 Bean 或者是否需要装载某个配置类等。
  >
  > 在Spring Boot的自动装配过程中，它会在META-INF/spring.factories文件中查找实现了AutoConfiguration接口的类，这些实现类会自动注册到Spring的容器中。在启动Spring Boot应用程序时，Spring Boot根据classpath路径上的依赖关系和已存在的Bean来确定哪些自动配置类需要启用，进而根据这些自动配置类中定义的Bean创建相应的Bean，从而实现了自动配置。
  >
  > Spring Boot还提供了一种非常方便的自定义自动配置的方式，即创建一个@Configuration类，在该类上添加@EnableAutoConfiguration注解，并重写一个或多个@Bean方法，从而可以定制一些特殊的自动配置。
  >
  > 总之，Spring Boot 自动装配的核心就是：根据条件自动创建或注入 Bean，使得应用程序能够更加快速、方便地进行开发。

* (2) 如何解决前端和服务端跨域问题(高频)

* > 跨域问题指的是在浏览器的同源策略下，当一个网页的脚本想请求另一个网页的资源时，会被同源策略阻止，从而产生跨域问题。常见的解决跨域问题的方法有以下几种：
  >
  > 1. JSONP
  >
  > JSONP是一种跨域解决方案，通过动态创建script标签，利用script标签没有跨域限制的特性，向服务器发送请求并在前端页面上接收并解析返回的数据。具体实现是在前端页面定义一个回调函数，服务器将数据作为参数传递到该回调函数中返回。需要服务器端配合支持JSONP。
  >
  > 2. CORS
  >
  > CORS（Cross-Origin Resource Sharing）是HTML5中提出的一种跨域解决方案，通过在服务端设置Access-Control-Allow-Origin，Access-Control-Allow-Methods等响应头信息来允许前端页面跨域请求服务器资源。需要服务端支持CORS。
  >
  > 3. 代理服务器
  >
  > 可以通过在服务端设置一个代理服务器，使得浏览器与代理服务器的请求不会被浏览器拦截，从而实现跨域访问其他服务器资源的目的。
  >
  > 4. Nginx反向代理
  >
  > 可以在Nginx服务器上通过反向代理的方式将请求代理到目标服务器上，从而实现跨域请求资源的目的。
  >
  > 以上几种方法都是有效的跨域解决方案，选择哪种方法主要取决于具体情况和需求。

7.熟悉java常用的设计模式，并在实际开发种使用过几种

(1) 单例，工厂责任链，代理模式，模板方法掌握这几个就行。 (使用场景我会在下期项目经验里面写)

8.熟悉redis, 有几种数据结构的使用经验。

* (1) redis 5中常用的数据结构，区别

* > 1. String：字符串类型，可存储字符串、整数或者浮点数；
  > 2. List：列表类型，支持在头部或尾部添加或者删除元素，也支持获取某个索引位置上的元素；
  > 3. Set：集合类型，支持添加、删除、查找元素，同时也支持对集合求交、并、差等操作；
  > 4. Hash：哈希类型，存储一个字段和值的映射表，常用于存储对象或者结构化数据；
  > 5. Zset：有序集合类型，类似于集合，但是每个元素都有一个权重，可以按权重排序。
  >
  > 这些数据结构之间的区别主要在于数据的存储方式和支持的操作，使用不同的数据结构可以更高效地完成不同的操作。例如，对于需要排序的数据，可以使用有序集合；对于需要求交、并、差等操作的数据，可以使用集合等等。

* (2) 这几种常见数据结构的使用场景

* (3) redis如何跟数据库保证数据一致性

* > Redis与数据库保证数据一致性的方法：
  >
  > 1. 应用层控制一致性：在应用程序中，手动控制 Redis 的写操作和数据库的写操作的原子性，确保这两个操作同时成功或同时失败，从而保证数据一致性。这种方法的优点是实现简单，缺点是需要额外的代码，容易出错，并且性能不佳。
  >
  > 2. 采用消息队列：将 Redis 中写操作的消息发送到消息队列，由消息队列来异步处理这些消息，最终保证 Redis 和数据库中的数据一致性。这种方法的优点是实现简单，具有一定的可靠性和性能，缺点是需要引入消息队列，增加了系统的复杂度和维护成本。
  >
  > 3. 利用 Redis 的事务机制：Redis 提供了事务机制，通过事务机制，可以将多个写操作组合成一个事务，以确保这些操作的原子性。使用事务机制可以确保 Redis 中的写操作和数据库中的写操作一致。这种方法的优点是实现简单，性能较好，缺点是需要控制事务的原子性。
  >
  > 4. 利用 Redis 的 Lua 脚本：Redis 支持 Lua 脚本，可以使用 Lua 脚本来实现 Redis 中的写操作和数据库中的写操作的原子性，从而保证数据一致性。这种方法的优点是实现简单，性能较好，缺点是需要学习 Lua 语言。

* (4)常见问题，缓存穿透，击穿，雪崩怎么处理

* > 缓存穿透、缓存击穿和缓存雪崩是 Redis 缓存常见的三种问题，它们分别指的是：
  >
  > 1. 缓存穿透：指的是大量查询一个不存在的 key，导致请求绕过缓存直接请求数据库，导致数据库压力过大甚至宕机。
  > 2. 缓存击穿：指的是一个高频的 key 在缓存过期时被大量请求，导致这些请求绕过缓存直接请求数据库，导致数据库压力过大甚至宕机。
  > 3. 缓存雪崩：指的是缓存服务器宕机或发生故障，导致缓存不可用，大量的请求绕过缓存直接请求数据库，导致数据库压力过大甚至宕机。
  >
  > 缓存穿透、击穿和雪崩都会导致请求无法命中缓存，直接请求数据库，影响系统的性能和稳定性。为了解决这些问题，可以采用以下方法：
  >
  > 1. 缓存穿透：可以采用布隆过滤器，对查询的 key 进行过滤，如果 key 不存在，则直接返回，避免绕过缓存直接请求数据库。
  > 2. 缓存击穿：可以采用热点数据预热、加锁等方式来解决。预热是指在缓存过期之前，提前将缓存中的数据更新到最新的状态；加锁则是指使用分布式锁来控制缓存过期时的并发请求，保证只有一个请求能够请求数据库。
  > 3. 缓存雪崩：可以采用数据备份、多级缓存等方式来解决。数据备份是指将缓存数据备份到多个节点上，当缓存节点发生故障时，可以使用备份节点来提供服务；多级缓存则是指在缓存层面引入多级缓存，将缓存数据分为多个层次，避免缓存失效时，大量请求绕过缓存直接请求数据库。

* (5)redis几种持久化方式，以及区别

* > 1. RDB（Redis DataBase）持久化方式：将某个时间点上的所有数据快照（Snapshot）存储到磁盘上的一个 RDB 文件中，该方式可以提供比 AOF 更高的性能和更小的文件尺寸，但是数据可能会丢失。
  >
  > 2. AOF（Append Only File）持久化方式：将每次写操作记录追加到 AOF 文件的末尾，通过回放 AOF 文件中保存的所有写操作来重建原始数据，该方式数据更加稳定，但是文件尺寸较大。
  >
  > Redis 6.0 之后提供了新的持久化方式：RDB/AOF 混合持久化方式。
  >
  > 区别：
  >
  > - RDB持久化方式：将当前时刻的 Redis 数据集以快照形式写入磁盘。在保存时，Redis 会fork出一个子进程来进行持久化操作，所以该方式可能会在某些操作时产生短暂的阻塞。
  > - AOF持久化方式：记录每一次的写操作，将其记录到一个追加的文件中，如果数据量较大，则AOF文件也会变得很大，而且每次重启Redis都需要重放所有的日志，导致重启时间很长。
  > - RDB/AOF混合持久化方式：同时开启两种持久化方式，可以充分利用两种方式的优点，保证数据的可靠性，而且重启时也可以使用 AOF 文件重建数据集，避免了 RDB 文件恢复时可能会丢失的一部分数据，同时 AOF 文件可以保证在 Redis 重启之前，所有的数据变更都可以被完整的保存下来。
  >
  > 在 Redis 的配置文件中，通过设置`save`指令可以配置 RDB 持久化策略，通过设置`appendonly`指令可以配置 AOF 持久化策略。可以同时开启 RDB 和 AOF 持久化方式，充分利用它们的优点。

* (6)redis内存溢出策略

* > 当 Redis 内存使用达到 maxmemory 限制时，Redis 会采用以下内存溢出策略：
  >
  > 1. noeviction：不清除数据，直接报错。如果没有设置 maxmemory-policy 或者设置为 noeviction，当 Redis 内存不足时，新写入操作会报错并返回客户端错误。
  >
  > 2. volatile-lru：删除最近最少使用的 key（设置了过期时间的数据）。在所有设置了过期时间的 key 集合中，选择最近最少使用的那个 key 并删除。
  >
  > 3. volatile-ttl：删除即将过期的 key（设置了过期时间的数据）。在所有设置了过期时间的 key 集合中，选择存活时间最短的那个 key 并删除。
  >
  > 4. volatile-random：随机删除过期 key。
  >
  > 5. allkeys-lru：删除最近最少使用的 key（不管是否设置了过期时间）。在所有 key 集合中，选择最近最少使用的那个 key 并删除。
  >
  > 6. allkeys-random：随机删除一个 key。
  >
  > 可以根据实际情况选择合适的策略，通常推荐使用 volatile-ttl 或 volatile-lru 策略，因为它们对业务影响较小。

9.熟悉linux常用系统命令，熟悉shell脚本的编写。

1: linux指令常见的一 些指令，查看进程、内存占用、cpu使用情况， 搜索关键字等

2:shel脚本水粉特有的技能，不了解的不做要求

注意:1，2年经验基础很重要，随便问点基础问题就知道你到底有多少东西，一个两个springcloud问题不会没事，但是事务的隔离级别，反射这些基础不会可能直接就没了，所以1, 2年经验的基础很重要，基础扎实了

还是有地方入职的。