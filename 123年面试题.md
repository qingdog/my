## 高频面试题

老弟们面试题重点要看 mysql，java 基础，spring，jvm，juc，redis，以及使用的一些场景相关的。

像springcloud，springboot，mq 这块不要深究，了解基础常见面试题就行了，毕竟没深入研究过问难的也难回答。不要走偏了，老弟们。

该套面试题涉及一些关键字和一些技术的真实使用场景都有涉及，比如 volicatile 关键字（参考之前多线程导入），syschronize 关键字，线程池，反射，threadlocal，redis 的5种数据结构真实项目使用，以及后续的一系列衍生出的问题都整理了，用自己的话组织了，比较常见的面试题还是找的答案并自己整理了语言。 

1. 说一个栈溢出的例子
	
	* 方法无限递归 
2. 说几个堆溢出的例子
    * 循环创建对象，或者一次性从数据库查出很多数据
3. 说一个元空间溢出的例子

    * 循环利用反射创建对象
4. 你知道什么是跨域问题吗？

    * 浏览器为了让自己更安全，设置了一种同源策略，"协议+域名+端口"三者都相同才算同源，不然会阻止一些请求。
5. 如何解决跨域问题？ 
    * （1）创建一个过滤器，然后把一些来源，请求头和请求方法等都设置成全部允许 
    * （2）可以在类或者方法上面加@CrossOrigin 注解
    * （3）还可以在 nginx 配置文件配置允许跨域
6. 你知道哪些加密算法 
    * （1）我知道有 MD5 算法，MD5 算法主要用的是哈希函数，不可逆，无论传入多长的字符串，MD5 都会输出长度为128bits 的一个串。
    * （2）还有 DES 加密算法，他的话是主要是64 位为分组对数据加密，它的密钥长度 是 56 位，加密解密用同一算法。
    * （3）对 RSA 也了解一点，这种加密算法是将两个大素数相乘很容易，但想要对这个乘积进行因式分解就比较困难了，所以一般将乘积作为加密密钥。
7. 如何保证你写的接口的安全性

    * 最好使用 https 协议，在 http 和 tcp 之间添加一层加密层(SSL 层)，这一层负责数据的加密和解密，这样就会防止数据被抓包；第二种做法可以在每次请求中加入当前的时间，服务器端会拿到当前时间和消息中的时间相减，看看是否在一个固定的时间范围内比如5分钟内；这样恶意请求的数据包是无法更改里面时间的，所以5分钟后就视为非法请求。 
    * 加签名:比如使用 md5 算法，将需要提交的数据通过某种方式组合和一个字符串，然后通过 md5 生成一段加密字符串，客户端和服务端都计算一份，防止数据传输被篡改。
8. sql 语句什么时候会出现 filesort 
    * 一般 sql 有 order by 排序产生，索引使用不当的情况下会出现，比如 select * from a where type = 5 order by createtime desc，这类语句一般会产生 Using filesort 这个选项，即使在type 和createtime上分别添加了索引。
    * 因为先根据 type 的索引从所有数据信息中挑选出满足 type = 5 条件的，然后根据 createtime 列的索引信息对挑选的数据进行排序，所以产生了 Using filesort 解决办法:可以在 type, createtime 两列上建立一个联合索引
9. Springboot 动态切换数据源这个你知道吗

    * 这个我切换过，需要继承 Spring 的AbstractRoutingDataSource抽象类，然后重写 determineCurrentLookupKey()这个方法（可以说是重写一个什么什么 key 方法），因为这个方法是设置数据源的，然后这个方法里面 return 一个数据源，这个数据源我们可以事先配几个数据源，然后程序启动加载全部数据源设置进子类里面，最后根据就可以根据传值获取想要的数据源了。

### 多线程

1. Arraylist 在多线程下会出现什么异常

    * ConcurrentModificationException（并发修改异常）

   为什么： 

   * 在多个线程进行 add 操作时可能会导致elementData 数组越界，还会导致一个线程的值覆盖另一个线程添加的值

   那怎么处理 

    * （1）使用 Vector 容器，也是加了 synchronizedList 

    * （2）使用 Collections 的静态方法 synchronizedList(List< T> list) 

    * （3）采用 CopyOnWriteArrayList 容器

2. 那你跟我说说 CopyOnWriteArrayList 原理

    * 就是往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对 CopyOnWrite 容器进行并发的读，而不需要加锁，有点读写分离的思想。

3. 那你觉得 CopyOnWriteArrayList 会有什么问题

   （1）内存占用问题。因为 CopyOnWrite 的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存。

   （2）数据一致性问题，因为还没复制完全的时候，线程读取的还是旧的数据里面的数据，只能保证最终一致性。

4. Hashmap 在多线程情况下会出现什么问题

    * ConcurrentModificationException（并发修改异常）put 的时候导致的多线程数据不一致。多线程同时会抢到一个位置，覆盖了数据。在扩容的时候，jdk1.8 之前是采用头插法，当两个线程同时检测到 hashmap 需要扩容，在进行同时扩容的时候有可能会造成链表的死循环。 

   怎么解决 

   （1）HashTable 直接 syschronize 锁 put 方法，不推荐

   （2）ConcurrentHashMap（推荐）

5. Hashmap 跟 ConcurrentHashMap 区别

   （1）Hashmap 允许 key 和 val 为 null，ConcurrentHashMap不允许

   （2）Hashmap 线程不安全，ConcurrentHashMap 线程安全jdk1.7 对整个数组进行分段（每段都是由若干个hashEntry 对象组成的链表），每个分段都有一个 Segment 分段锁），每个Segment 分段锁只会锁住它锁守护的那一段数据，多线程访问不同数据段的数据，不会加锁。ConcurrentHashMap ：jdk1.8ConcurrentHashMap在JDK1.8 中采用 Node+CAS+Synchronized 实现线程安全，取消了segment 分段锁，直接使用 Table 数组存储键值对（与1.8 中的HashMap一样），主要是使用 Synchronized+CAS 的方法来进行并发控制，锁的粒度大大降低了。

6. 那为什么 ConcurrentHashMap 在JDK1.8 中为什么要使用内置锁 Synchronized 来替换 ReentractLock 重入锁？

    * Jdk1.6 对 synchronized 进行了优化和升级，引入了锁升级的概念，不再都是重锁的情况

7. ConcurrentHashMap 的 get()方法需要加锁吗？

    * 不需要，get 操作可以无锁是由于 Node 的元素val 和指针next 是用 volatile 修饰的，在多线程环境下线程A 修改结点的val 或者新增节点的时候是对线程 B 可见的。

   

### sql
1. 假如一张数据量很大的表，百万，千万级别的，如果提高深度分页的查询速度 

    * 这个我知道我主要有两种方式可以优化 这个可以走覆盖索引 `select * from orders_history where type=8 and id=(select id from orders_history where type=8 limit 100000,1)`，1秒多 limit 100;先走覆盖索引查出 id，再根据id 找详情。
    * 如果 id 递增的话，用 between 更快，能达到几十毫秒级别的`select * from orders_history where type=2 and id between 1000000 and 1000100 limit 100;`几十毫秒。

2. 查找表中多余的重复记录，重复记录是根据单个字段(Id)来判断 

    * `select * from 表 where id in (select id from 表 group by id having count(Id) > 1)`

3. 删除表中多余的重复记录(多个字段)，只留有rowid最小的记录 

    * `delete from 表 a where (a.Id, a.seq) in (select Id, seq from 表 group by Id, seq having count() > 1) and rowid not in (select min(rowid) from 表 group by Id, seq having count()>1)`

4. 查找表中多余的重复记录(多个字段)，不包含rowid最小的记录 

    * `select * from 表 a where (a.id, a.seq) in (select id, seq from 表 group by id, seq having count() > 1) and rowid not in (select min(rowid) from 表 group by id, seq having count()>1)`

5. 假如给一张数据量很大的表加索引，或者加字段，需要怎么操作

    * 肯定不能直接加，如果直接加字段操作会锁表，还可能造成数据库卡死。 

      我的想法有 2 种方法， 

      ① 创建一个临时的新表，首先复制旧表的结构（包含索引）

      ② 给新表加上新增的字段 

      ③ 把旧表的数据复制过来

      ④ 删除旧表，重命名新表的名字为旧表的名字不过上述这种会造成比较少的数据损失，在第三步可能还有数据写入进旧表 还有一种方法可以在从库进行加字段操作，然后主从切换，这样数据丢失可能性很小

6. 线程池的核心线程数是 new 一个线程池就立马创建吗

    * 这个可以自己设置的，默认情况下是当有任务提交的时候才开始创建，而且就算空闲的线程足以处理新任务，它仍然会创建新的线程去 处 理 ， 直 到 核 心 线 程 数 达 到 最 大值。当然我们可以调用prestartAllCoreThreads()方法先创建所有核心线程。正常情况下，核心线程池中的线程一但创建了就不会自动被销毁，除非设置了allowCoreThreadTimeOut=true，或者是线程在执行任务的时候报了异常。

7. 核心线程数能为 0 吗 

    * 可以为 0，当核心线程数为 0 的时候，会创建一个非核心线程进行任务处理，其他的跟线程池工作原理一样。

8. 线程池如何判断是否需要回收

    * 线程工作线程启动后，就进入 runWorker(Worker w)方法。里面是一个 while 循环，线程池会判断getTask()是否返回null，如果返回 null 就会被回收。

9. Redis setnx 分布式锁有哪些问题

    * 业务执行时间过长，可能会把其他线程的锁给删了如何解决： 我使用的 redisson，他有个看门狗机制，会检测程序是否执行完，没执行完会给锁增加过期时间。

10. 那你说说这个看门狗机制的实现原理

    * 当我们在调用 redission 的 lock 方法时没有指定超时时间，就会使用看门狗的默认时间 30 秒，只要抢锁成功的线程，就会开启一个延迟任务，超过看门狗时间的 1/3 就会重新给这个锁设置过期时间。

11. Threadlocal 你了解吗 

     * ThreadLocal 提 供 线 程 局 部 变 量。

       每一个线程在访问ThreadLocal get 或 set 方法都有自己的变量副本，线程之间数据互不干扰。 是怎么实现的？ 

     * 当线程请求时，会给每个线程 new 一个自己的 ThreadLocalMap，当执行 set 方法时，值是保存在当前线程的ThreadLocalMap（跟 hashmap 差不多，是个 entry，保存键值对）里，以当前 threadlocal 对象为 map 的 key，设置的值为 map 的value，当执行get 方法中，先通过线程名称获取当前线程的 ThreadLocalMap，然后再通过当前threadlocal 对象获取自己的 value 属性。

12. 聊聊 Threadlocalmap（或者Threadlocalmap 用了哪种引用，为什么） 

     * 底层用了弱引用，其实底层是用了2 层包装，第一次包装是将thredlocal 对象变成一个弱引用对象，第二层是定义了一个entry 对象继承包装后的 threadlocal 对象实现扩展。

13. 为什么要使用弱引用（threadlocal为什么使用完要remove）

     * 避免内存泄露，因为方法执行完毕后，栈帧中的引用断开，但是此时 Threadlocalmap 里面的 threadlocal 对象还引用着堆里面的实例，造成内存泄露，如果改为弱引用，只要垃圾回收就会回收，降低了内存泄露的风险，remove 可以把 threadlocalmap 的key 设置成null，这样 gc 就会回收了。

14. 你在项目中有用过 threadlocal 吗？

     * 以前做了一个登录用过，就是业务要区分用户是是登录用户还是临时用户，在拦截器里面创建了一个 threadlocal 对象，然后把用户的信息对象存进去，比如临时用户给他生成一个标识，然后再传到controller 进行不同业务逻辑的判断。

15. 你项目中用过 syschronize 吗

      * 用过，以前用过一个 OkHttpClient 类，创建这个类的对象时没有 用同一个 OkHttpClient 实例并重复使用，每次请求都创建一个新的连接对象，而每个实例都有自己的连接池和线程池，从而导致线程大量堆积，我创建了一个单例模式，然后引入syschronize，然后双重校验，并且加 volatile 修饰这个单例属性。 

      * ```java
        class GetOkHttpClient { 
            public static volatile OkHttpClient instance = null; 
            private GetOkHttpClient() {} 
            public static OkHttpClient getInstance() { 
                if (instance == null) { 
                    //DCL(双端检索)机制 
                    synchronized (GetOkHttpClient.class) { 
                        if (instance == null) { 
                            instance = new OkHttpClient(); 
                        } 
                    } 
                } 
                return instance; 
            } 
        }
        ```

16. 谈谈 Syschronize 锁（syschronize 是怎么加锁的）

      * 其实每个 java 对象都是由对象头，实例数据和对其填充三部分组成，Syschronize 的锁是存在 java 对象头的 mark word 中，锁升级主要看mark word 中锁的标志位和释放偏向锁的标志位。

        Jdk1.4 后 syschronize 做了什么优化

      * Jdk1.4 及之前无锁直接上升到重量级锁，1.4 之后引入偏向锁和轻量级锁的概念，让并发性更好。

17. 那你解释一下这 4 种锁升级是怎么升级的

     * （1）无锁：一个线程都还进来，此时是无锁的状态。
     * （2）偏向锁：当一个线程来访问时，会将markword 偏向锁标识改成当前线程 id，下次该线程访问只要判断标识位是否是当前线程，如果 是则自动获取锁，不需要跟重量级锁一样加锁解锁导致内核态和用户态重复切换，当出现锁竞争时需要释放该锁。
     * （3）轻量级锁：如果 A 持有偏向锁，B 来抢锁失败了，会一直cas抢锁，此时锁升级为轻量级锁，a 线程也会由之前的偏向锁转为轻量级锁，并且还是持有该锁。 
     * （4）重量级锁：当竞争线程较多，并且 cas 自旋长时间抢不到锁会升级为重量级锁。

18. Syschronized 修饰静态和非静态的区别

     * 静态方法锁的是 Class 实例，非静态方法或属性锁的是对象的实例，修饰代码块时锁的是传入的对象，即 this。

19. Redis 5 种数据结构

     * String、Hash、List、Set、Zset

20. Redis5 种数据结构你都使用了哪些，怎么用的

     * （1）String 用的最多，比如存登录用户的token，还有项目中一些键值对的地方 

     * （2）Hash 结构这个也用过，比如文件推送平台，需要区分上游哪个平台传送过来的文件，然后文件还要再一次区分是那种类型的文件。或者针对用户手机唯一 id，大数据会给一个接口先判断用户是属于哪种类型的用户，例如 4 种类型 A,B,C,D，我们平台还需要根据用户所使用的手机类型做进一步区分，比如安卓和ios，然后再给这个用户推送不同的广告，后台会先配置 A,B,C,D 四种类型的用户，比如少年，青年，中年，老年。这个最为 hash 的 key 区分最外层，然后内层的 map 再根据手机类型进行区分。 

     * （3）Set 结构也用过，比如文件推送过了，我们可以把当天的文件名保存进一个 set 集合，这样通过 set 的 sismember 命令可以快速判断。或者把拉黑的用户 id 存入 set 集合中，用户进入首页直接判断是否在set 集合中。 

     * （4）Zset 也用过，比如我们平台会给用户app 上面推广告，后台会配置这个广告的运营时间，然后会把这个广告的点击数存在zset 当做是分数，公司后台会根据不同的时间投放点击数不同的广告，这个到了时间我就会根据 zset 的 zrangebyscore 取的对应的广告进行投放。

21. 这 5 种数据结构底层是什么数据结构有了解吗（简单描述，不过多写，粉丝难接受）

     * （1）String：底层用的是动态字符串，有动态扩容的能力，如果字符串小于 1M 扩容是字符串 2 倍+1,如果大于1M，则为扩展后的字符串长度+1M+1,加 1 是结束标识，在字符串长度不一样的时候还会采用不同的编码格式加快查询效率。 

     * （2）List：redis 最早用的是 ziplist（压缩链表），但是当元素个数过多，它的查找效率就会降低。而且如果在ziplist 里新增或修改数据，ziplist 占用的内存空间还需要重新分配（3.0 版本及之后废弃）。Redis 先是在 3.0 版本中设计实现了 quicklist。quicklist 结构在ziplist 基础上，使用链表将 ziplist 串联起来，链表的每个元素就是一个ziplist。这种设计减少了数据插入时内存空间的重新分配，并且quicklist 限制了每个节点上 ziplist 的大小，查询效率不会那么低。 Redis 在 3.0 版本中，又实现了 listpack 结构（没有完全替换，不深入介绍，只要达 quicklist 即可）。 

     * （3）Set ：Dict 字典，值为键，value 是null。

     * （4）Zset ：当元素个数小于 128 并且每个元素小于64 字节采用ziplist 存储，来节省内存。其他情况采用 Dict 字典加跳表的数据结构，DictJI 检查键的唯一性，跳表实现快速排序和查找。

     * （5）HASH：默认采用 ziplist，ziplist 相连的两个节点保存key 和value。当数据量大时，ziplist 会有查询效率问题，会转成Dict 结构存储。

22. Redis 网络模型了解吗（了解即可，有点难）我知道有 3 种 select，poll 和 epoll 都使用了 io 多路复用原理。 但是 Select 监听文件（linux 一切东西都是以文件形式表现）有上限，还涉及不少内核拷贝，并且有事件就绪了需要遍历所有的文件找出就绪的事件。 Poll 采用链表存储文件解决了 select 监听select 监听文件上限的问题，但是有事件发生依然需要遍历整个文件。Epoll 采用红黑树解决了监听文件上限问题，并且加快了查询就绪事件的效率，并且添加效率也很快。

### Linux

1. Linux 基本指令 

    * （1）ls：列出所有文件及文件夹。 
    * （2）pwd：找出当前所在的文件目录。
    * （3）ps -ef|grep 名称，找出这个应用进程。 
    * （4）rm -rf 递归删除， 
    * （5）cp -rf 递归复制。 
    * （6）chmod：给文件改权限。 
    * （7）lsof -i:端口号 查看端口是否被占用。
    * （8）cat 文件名 | grep 关键字，从文件中查找该关键字的记录。
    * （9）tail -f 文件名查看文件里面的内容，实时打印。
    * （10）vi：编辑文件 
    * （11）set nu:给文件标识行数。 
    * （12）Linux 创建文件的几种方式：touch 文件名，vi 和vim，echo。
    
2. Mysql 默认的隔离级别 

    * 可重复读

3. 说下不可重复读和幻读的区别
    * 不可重复读：在并发更新时，另一个事务前后查询数据不一样
    * 幻读：删除或者新增产生数量变化时，另一事务修改或者删除发现影响的行数不一样
4. 知道什么是当前读和快照读吗
    * 最普通的查询语句就是当前读
    * 不加锁加锁是快照度，比如 insert，delete，update，selet * from 表名 for update
5. Mysql 是怎么实现可重复读的

    * （1）快照读：基于 mvcc 多版本并发控制实现的，及 Undo Log+ readview 实现的，Undo Log 保存了历史快照，Read View 可见性规则帮助判断当前版本的数据是否可见，当事务执行SQL 语句前，会得到一个 Read View，可重复读隔离级别下，一个事务里只会获取一次readview，后面都是共用的，从而保证每次查询的数据都是一样的。
    * （2）当前读：基于行数加间隙锁实现的。
6. 间隙锁了解吗？ 

    * 间隙锁主要是在索引记录之间的间隙加锁，从而保证某个间隙内的数据在锁定情况下不会发生任何变化

7. Mysql 如何排查死锁 

    * 可以修改 MySql 系统参数 innodb_print_all_deadlocks 设置成1，开启状态，这样当发生死锁时，死锁日志会记录到MySQL 的错误日志文件中。 也可以查看线上的服务器日志

8. Mysql 有哪几种日志文件 

    * 我知道的主要有 6 种日志，重做日志（redo log）、回滚日志（undolog）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slowquery log）、一般查询日志（general log）

    都有什么作用 

    * （1）binlog 是 MySQ 服务层维护的一种二进制日志，主要做主从复制、数据恢复和备份； 
    * （2）undo log innerdb 储存引擎层面的日志，提供回滚和多版本并发控制下的读(MVCC)； 
    * （3）redo log 数据备份和数据提交；
    * （4）errorlog mysql 服务器执行错误时记录进这个错误日志； 
    * （5）slow query log mysql 开启了慢查询，慢sql 会写入这里；
    * （6）general log 记录所有的操作日志一般不开启，耗费数据库性能。

9. redo log 与 binlog 的区别 
    * （1）redo log 是在 InnoDB 存储引擎层产生，而binlog 是MySQL数据库的上层产生的 
    * （2）写入磁盘的时间点不同，binlog 在事务提交完成后进行一次写入。而 redo log 在事务进行中不断地被写入
    * （3）binlog 在写满或者重启之后，会生成新的binlog 文件，redolog 是循环使用。
10. Mysql 锁你了解几种（都有什么作用）主要了解 4 种 
    * （1）行锁 锁定一行，锁的是索引，解决当多个线程对数据库进行操作时，会带来数据不一致的情况，会有死锁情况；
    * （2）表锁 锁定整张表，也是防止解决当多个线程对数据库进行操作时，会带来数据不一致的情况，不会有死锁；
    * （3）间隙锁 只有在可重复读的情况下才会有可能产生此锁，可以避免幻读，锁的是索引的一段间隔，会有死锁情况；
    * （4）意向锁，是一种表级锁，与行锁可以同时存在，目的是防止加表锁时需要全表扫描有没有行锁，不会有死锁情况。
11. 什么是索引下推 
     * 在 mysql5.6 之前，没有索引下推，比如建立了一个联合索引，先会从第一个索引里面找到合适的数据，再回表查，再过滤，造成多次回表。 
     * 而5.6 之后有引入索引下推，使得MySQL能够在进行索引扫描的同时，将过滤条件下推到存储引擎层面执行，主要直接就可以根据两个联合索引过滤出需要的数据，再回表，减少了回表查的次数。
12. Springmvc 的请求流程（一般springmvc 就这个问点比较高频） 

     * （1）请求先到前端控制器 DispatcherServlet，如果有过滤器先到过滤器。 
     * （2）然后 DispatcherServlet 会根据请求的url 找到合适的控制器
     * （3）然后控制器调用 service 调用 dao 处理业务逻辑
     * （4）最后会返回一个 ModelAndView 
     * （5）DispatcherServlet 渲染 ModelAndView 最后展示在页面

13. 过滤器，拦截器，DispatcherServlet 执行顺序是什么样的

     * 先到过滤器再到 DispatcherServlet 再到拦截器

14. Spring 三级缓存存的都是什么对象

     * 一级，保存的都是初始化后的 Bean 
     * 二级，还没进行属性注入，经过三级缓存处理可能是原对象或代理对）
     * 三级，存放一个对象工厂，里面保存的都是刚实例化的对象

     1. 一级缓存：单例对象的缓存。在Spring容器中，单例的Bean在第一次创建后会被缓存起来，后续的请求将直接返回缓存的对象，而不会再次创建。
     2. 二级缓存：早期的原型对象缓存。在Bean创建过程中，如果遇到了循环依赖的情况，Spring会将尚未进行属性注入的原型对象（即尚未完全初始化的对象）放入二级缓存中，以便在解决循环依赖时使用。
     3. 三级缓存：早期的对象工厂。在Bean的创建过程中，Spring会将尚未完成初始化的Bean对象（包括尚未进行属性注入的对象）放入三级缓存中，以便在解决循环依赖时使用。三级缓存中存放的是一个ObjectFactory对象，它可以用来创建或提供尚未初始化的Bean对象。

15. 你在开发中哪些地方用到了反射

     * 文件交换平台，因为对文件操作的步骤配置都不相同，这个我是用了一个枚举，然后枚举第一值是后台配的文件操作步奏具体的code， 第二个值为文件操作类的包名类名，比如1 代表解压，2 代表转A码，3 代码压缩，则后台配置，1，2，3，这样就可以直接通过这个后台配置的 code 找到找到类的包名类名通过反射生成对象进行具体操作。

16. 那你这样写的好处是什么？

     * 提高了程序的灵活性和扩展性，因为再写一个类我只要配置一个枚举就行了，不用在代码里面到处 new 新的对象。

17. Java new 一个对象要做哪些事

     * （1）在堆区分配对象需要的内存 
     * （2）对所有实例变量赋默认值 
     * （3）执行实例初始化代码 
     * （4）Spring 通过三级缓存解决循环依赖问题（较难，不过多描述，可以看视频理解，尚硅谷周瑜的手写 spring，很详细，还有教你如何处理） 

### Java 常规题

1. java 语言的三大特性 

    * （1）封装：封装的话主要就是隐藏类内部的细节，提供接口给外部调用就行了，比如像微服务开发，其他部门只要把接口依赖给我们就行了，我们并不知道他们接口内部的细节。

    * （2）继承：几个类可以继承一个公共类的属性和方法，实现代码的复用，并且子类还可以定义自己的属性和方法。

    * （3）多态：父类的引用指向子类的对象，并且该引用对象可以表现不同的行为。

2. Java 使用基本数据类型的包装类有什么好处这个主要是让基本数据类型具有 java 对象相关的属性和方法，可以增加基本数据类型的操作。 还有像 java 集合申明泛型时也必须要求Object 类型，所以基本数据类型放不进去。

3. java 基本数据类型和包装类型有什么区别基本数据类型存栈里面，包装类型对象存堆里面，初始值不一样，基本数据类型除了 boolean 是 false，其他的都是0，包装类型初始值都是 null，像集合里面的泛型都是使用包装类型，没法设置基本数据类型。

4. &和&&的区别 

    * （1）&:逻辑与，a==b&a==c 时，即使 a==b 已经是false 了，依然还会判断 b 是否等于 c,容易造成空指针异常

    * （2）&&：短路与，a==b&a==c 时，如果a==b 是false 了，那么不会再判断后面的条件是否满足可以避免空指针。

5. Java 中 StringBulider、StringBuffer 有什么区别

    * StringBuffer：内部加了锁，线程安全； 
    * StringBulider：是非线程安全的，并发高。

6. 谈谈 static 关键字

    * 抽象类的抽象方法不能被 static 修饰，因为静态方法不能被重写。静态方法里面不能调用非静态方法，因为非静态方法调用需要创建对象； static 不能修饰局部变量，因为 static 修饰的变量作用域是全局

7. 静态方法能被重写吗，为什么

    * 不能，因为方法重写是在程序运行时选择要执行哪个方法，而static 修饰的方法是在程序编译时就已经确定要执行哪个方法。

8. 重载和重写的区别 

    * 都是多态的表现方式 重载是编译时就确定要执行哪个方法了，重写是要在运行时才知道要知道执行哪个方法 重载发生在同一个类，方法名相同，参数类型不同，个数不同或者都不同可认为的方法的重载，而重写发生在父类子类之间，子类方法名和参数列表都要求和父类一样

9. 接口和抽象类有什么相同点和区别相同点：

      （1）两个都不能被实例化 接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。 不同点 

      （1）jdk1.8 之前接口中全部都要求是抽象方法，java 8 中定义default 方法体，而抽象类可以有非抽象方法。

      （2）实现接口的关键字为 implements，抽象类为extends。一个类可以实现多个接口，但只能继承一个抽象类。

      （3）最主要的区别还是接口强调一种功能的实现，而抽象类强调类之间所属关系。 

      （4）接口成员变量默认为 public static final 而抽象类中成员变量默认default

10. String 类能被继承吗 

    * 这个不能被继承，因为 String 是 final 修饰
	
11. 如何自定义一个异常 

       * 首先申明一个异常类继承 exception 或者runtimeException 类，其次编写两个构造方法，一个有参一个无参 Java 集合（重点hashmap）

12. ArrayList 和 LinkList 的区别 

       * （1）ArrayList 底层是动态数组，而 LinkList 底层是双向链表
         
       * （2）ArrayList 随机读取元素较快，可以通过下表直接找到，而linkList 需要遍历整个链表长度。删除和插入数据linklist 性能较好，只要断开链表指针重新更改指向即可，而 Arraylist 会涉及底层数组的缩容和扩容。 
         
       * （3）LinkList 要占用更多的内存，LinkList 除了节点存储真实数据还要存储前后节点的位置

13. 如何移除 list 中一个元素 

       * 方式一，使用 Iterator ，顺序向下，如果找到元素，则使用remove方法进行移除。 
       * 方式二，倒序遍历 List ，如果找到元素，则使用remove 方法进行移除。 方式三，正序遍历 List ，如果找到元素，则使用remove 方法进行 移除，然后进行索引 “自减”。

14. 你知道 TreeMap 吗 

       * TreeMap 实现了 NavigableMap 接口，能够对map 的key 进行排序。底层是一个数组，但是数组里面的元素是红黑树，数据存在这颗红黑树上面。

15. 在日常开发中使用过的 java 集合类

       * ArrayList，HashMap，HashSet，ConCurentHashmap（多线程组装数据，加快返回速度）

16. 为什么 HashMap 的底层数组长度为何总是2 的n次方

       * 主要还是使存入的数据分布均匀，减少冲突。

17. Hashmap put 原理 

         * （1）取 key 的 hashcode 进行高位运算，返回hash 值
         * （2）如果 hash 数组为空，直接 resize() 
         * （3）对 hash 进行取模运算计算，得到key-value 在数组中的存储位置 i 
       	* ①如果 table[i] == null，直接插入 Node 
          	* ②如果 table[i] != null，判断是否为红黑树。
          	* ③如果是红黑树，则判断 TreeNode 是否已存在，如果存在则直接返回 oldnode 并更新；不存在则直接插入红黑树，
             	* ④如果是链表，则判断 Node 是否已存在，如果存在则直接返回oldnode 并更新；不存在则直接插入链表尾部

18. Hashmap 链表超过 8 一定会转为红黑树吗 

       * 不是，链表超过 8 且数据总量超过 64 才会转红黑树

19. Jdk1.7 和1.8 hashmap 有什么区别
       * （1）在 java1.8 中，如果链表的长度超过了8，那么链表将转换为红黑树。(数据总量必须大于 64,小于 64 的时候只会扩容) 
       * （2）发生 hash 碰撞时，java1.7 会在链表的头部插入，而java1.8会在链表的尾部插入

20. HashMap 和 hashTable 的区别
       * （1）Hashtable 是线程安全，HashMap 是非线程安全
       * （2）HashMap 可以使用 null 作为 key 而Hashtable 则不允许null 作为key 
       * （3）HashMap 继承了 AbstractMap，HashTable 继承Dictionary 抽象类 
       * （4）HashMap 的初始容量为 16，Hashtable 初始容量为11，两者的填充因子默认都是

21. HashMap 扩容时是

       * 当前容量翻倍即: capacity *2，Hashtable 扩容时是容量翻倍+1 即:capacity *2+1

22. Hashmap 初始容量和负载因子是多少

       * 16 和 0.75

### 反射

(这个对于年限不高的粉丝非常重要，比较基础，问的多)

1. 你知道创建一个对象有哪几种方式吗
    * （1）序列化反序列化可以 
    * （2）通过 new 一个对象 
    * （3）通过反射创建也可以 
    * （4）还可以调用一对象的 clone 方法克隆一个对象

2. 什么是反射 

    * 反射是在运行状态中，对于任意一个类，能够动态获取类信息以及动态调用对象的方法的功能称为 Java 语言的反射机制。

3. 获得 class 对象的几种方式 

    * （1）类名.class 
    * （2）对象.getClass
    * （3）Class.forName(包名类名)

4. 开发中你觉得哪些地方用到了反射机制
    * （1）JDBC 中，利用反射动态加载了数据库驱动程序
    * （2）Tomcat 服务器中通过反射调用了 Sevlet 的方法
    * （3）Spring 通过 xml 文件生成 bean 对象并给属性赋值
    * （4）包括我开发中也有过把类型和类包名类名生成一个枚举，然后程序启动通过状态取出包名类名生成对象

5. 那你觉得反射有什么好处 

    * 提高了代码灵活性和扩展性，降低耦合性，不用硬编码具体哪个类

6. 如何通过反射创建对象并给属性赋值和调用方法? 

    * 通过一个全限类名创建一个对象 Class.forName(“全限类名”); 例如：com.mysql.jdbc.Driver Driver 类已经被加载到 jvm 中，并且完成了类的初始化工作就行了类名.class; 获取 Class<？> clz 对象 对象.getClass(); 
* 获取构造器对象，通过构造器 new 出一个对象Clazz.getConstructor([String.class]); 
    
    * Con.newInstance([参数]); 通过 class 对象创建一个实例对象（就相当与new 类名（）无参构造器) 
* Cls.newInstance(); 通过 class 对象获得一个属性对象 Field c=cls.getFields()：获得某个类的所有的公共（public）的字段，包括父类中的字段。 
    
    * Field c=cls.getDeclaredFields()：获得某个类的所有声明的字段，即包括 public、private 和 proteced，但是不包括父类的声明字段通过 class 对象获得一个方法对象 Cls.getMethod(“方法名”,class……parameaType);（只能获取公共的）
* Cls.getDeclareMethod(“方法名”);（获取任意修饰的方法，不能执行私有）
    * M.setAccessible(true);（让私有的方法可以执行）让方法执行 

    > IO 和网络编程不多写，这个面试频率不高而且难，优先以其他的为主，学完后可以自己了解一下多线程(很重要)

7. java 创建线程（Thread）的几种方式 
    * （1）继承于 Thread 类 
    * （2）实现 Runnable 接口 
    * （3）实现 Callable 接口 
    * （4）使用线程池

8. 线程的几种状态 

    * 创建，等待，执行，阻塞，死亡

9. 线程 yield 和 join 的区别 

    * yield 是放弃当前 cpu 的执行该线程，但是放弃时间不确定，可能刚刚放弃又获得了 cpu 执行该线程任务。
    * Join 是把指定线程加入到当前线程，当前线程阻塞，必须指定线程执行完了才会执行当前线程

10. 一个东西的引入必然有缺点和优点，线程池的优缺点？

    * 优点这个我觉得一个是能提高响应速度。还有就是方便管理线程，避免线程一直创建增加服务器压力 缺点的话我觉得引入线程池程序复杂度上去了，肯定要维护这个线程池，还有就是线程池也占用一定资源

11. 线程池的 7 大参数 

     * 主要有核心线程数，最大线程池，线程存活时间，时间单位，线程工厂，拒绝策略，阻塞队列

12. 工作原理 

     * 首先核心线程数处理任务，如果所有核心线程数还没执行完又来了任务，这个时候任务会先进阻塞队列（这里注意，很多人容易觉得 直接会触发最大线程）， 如果阻塞队列也满了核心线程数也没空闲线程，这个时候最大线程数的线程会去处理任务，如果最大线程数和核心线程数都没有空闲线程并且阻塞队列也满了，继续来任务就会触发拒绝策略

13. 你们公司用的什么线程池。参数怎么设置的? 

     * 我们公司用的是 Threadpoolexecute，参数可自己可配置的这种线程池。这个参数不是我设置的，但是我知道这些参数跟三个指标有关系，1.任务量、2.单个任务的处理时间、3 页面允许响应的最大时间，这三个指标有一个复杂的运算。 
     * 这个 up 说明一下，假如你用 excel 导入1000 条数据。任务量就是 1000，单个任务的处理时间就是一条数据插入数据库的时间，允许的响应时间就是前端多久给提示，比如导入成功这种的。

14. 你还知道哪几种线程池? 

     * 可缓存线程池，可定长度线程池，可定时线程池，单例线程池

15. 那开发中能不能直接使用这种线程池? 

     * 一般不用，这些线程池参数配置死了，不可控。

16. 拒绝策略有哪几种? 

     * （1）直接丢弃任务，抛异常。 
     * （2）不丢弃，用当前线程去执行任务。
     * （3）忽略，不抛异常。 
     * （4）移除最早进入队列的任务。 
     * （5）还可以实现一个拒绝策略处理器接口自己定义拒绝策略。

17. 你们公司用的什么拒绝策略? 

     * 我们公司用的是不拒绝，因为我们公司业务这个任务数据不能丢失。

18. 那你举个例子说一下你的线程池使用场景和流程

     * （1）因为我们公司有一个 excel 导入数据的过程，大概在5000条导入时间就会很长，单线程执行可能都要10 几秒页面才会返回，我是分批进行导入的，首先读出 excel 的5000 条数据，然后存入一个集合中，当时也验证了，大概在一批 200 条开启一个线程,最合适。首先用总数量除以 200 算出开启线程数量，然后for 循环里面用list 的 sublist 方法，一次循环取 200 条给线程去插入数据库，最后 5000 条数据大概 1 秒左右就返回了。
     * （2）还有个场景就是打开一个页面加载速度太慢了，因为页面取得数据来自很多表和其他部门的接口，这个也用多线程去异步查询然后组装了。

19. 多线程 execute 和 submit 的区别

     * （1）execute 只能提交 Runnable 类型的任务，无返回值。submit 既可以提交 Runnable 类型的任务，也可以提交Callable 类型的任务，会有一个类型为 Future 的返回值，但当任务类型为Runnable 时，返回值为 null。 
     * （2）execute 在执行任务时，如果遇到异常会直接抛出，而submit 不会直接抛出，只有在使用 Future 的 get 方法获取返回值时，才会获取异常

20. shutDown 和 shutdownNow 的区别
     * （1）shutDown() 当线程池调用该方法时,不能再往线程池中添加任何任务，否则将会抛出 RejectedExecution 异常。但是，此时线程池不会立刻退出，直到添加到线程池中的任务都已经处理完成，才会退出，包括队列里面的任务。 
     * （2）shutdownNow() 执行该方法，线程池的状态立刻变成STOP 状态，会试图停止所有正在执行的线程，不再处理队列中等待的任务但是正在执行的任务都执行完成了才能退出。

21. 线程池的核心线程数怎么设置
     * （1）CPU 密集型是 CPU 核数+1，+1 是因为CPU 密集型一般也有一些IO 操作，所以再加一个线程来把等待 IO 的CPU 时间利用起来；
     * （2）IO 密集型是 2 倍的 cpu 核数，是因为IO 操作CPU使用率并不高，因此可以让 CPU 在等待 IO 的时候去处理别的任务，充分利用CPU时间。 JUC 包面试题（这个不写太多，了解即可，太耗时间）1.Lock 和 Synchronizaed 的区别
     * （1）Lock（接口）是手动加锁、解锁，因此可能会出现死锁。可以设置公平或非公平，如果一个线程获取锁，其他线程可以不用等待。（tryLock()方法）。 
     * （2）Synchronizaed（关键字）自动解锁，不会死锁。是非公平锁， 如果一个线程获得锁，其他线程会一直等待。底层实现不一样： 
     * （1）synchronized: 底层使用指令码方式来控制锁的，映射成字节码指令就是增加来两个指令：monitorenter 和monitorexit。当线程执行遇到 monitorenter 指令时会尝试获取内置锁，如果获取锁则锁计数器+1，如果没有获取锁则阻塞；当遇到 monitorexit 指令时锁计数器-1，如果计数器为 0 则释放锁。 
     * （2）Lock 底层是 CAS+aqs+一个 volatile 关键字修饰的状态，实现的加锁解锁

22. 可重入锁了解吗？ 

     * 可重入锁的意思就是线程获取锁之后可以不用释放锁再次获取锁。

23. 举一个 java 死锁的列子

    ```java
    private static String A = "A";
    private static String B = "B";
    public static void main(String[] args){
        new DeadLockDemo().deadLock();
    }
    private void deadLock(){
        Thread threadA = new Thread(new Runnable(){
            @Override
            public void run(){
                synchronized(A){
                    try{
                        Thread.currentThread().sleep(2000); //当前线程睡眠2s
                    } catch (InterruptedException e){
                        e.printStackTrace();
                    }
                    synchronized(B){
                        System.out.println("AB");
                    }
                }
            }
        });
        Thread threadB = new Thread(new Runable(){
            @Override
            public void run(){
                synchronized(B){
                    try{
                        Thread.currentThread.sleep(2000);
                    } catch(InterruptedException e){
                        e.printStackTrace();
                    }
                    synchronized(A){
                        System.out.println("AB");
                    }
                }
            }
        });
        threadA.start();
    }
    ```

24. Java 如何定位一个死锁 
     * （1）jps 指令查看项目的 pid(进程 id) 
     * （2）然后使用 jstack -l pid 查看死锁信息
     * （3）通过打印信息我们可以找到发生死锁的代码是在哪个位置5.Lock 锁公平和非公平锁有什么区别非公平锁在调用 lock 后，首先就会调用CAS 进行一次抢锁，如果这个时候恰巧锁没有被占用，那么直接就获取到锁返回了。但是公平锁会判断aqs队列是否有线程处于等待状态，如果有则不去抢锁，直接排到队列后面等待。

25. 你有用过 juc 包下面哪些类

     * ConcurenthashMap、CountdownLarch、AtomicBoolean、线程池ConcurentHashMap(面试高频)

26. ConcurrentHashMap 在 JDK1.7 和JDK1.8 区别
     * （1）加锁的地方不一样，jdk1.8 的实现降低锁的粒度，jdk1.7锁的粒度是基于段的，每个段包含多个 HashEntry，而jdk1.8 锁的粒度就是Node。 
     * （2）数据结构不一样：jdk1.7：Segment+HashEntry。jdk1.8：数组+链表+红黑树+CAS+synchronized。

27. ConcurrentHashmap 的 key，value 是否可以为null。

     * 不行。如果 key 或者 value 为 null 会抛出空指针异常。因为 ConcurrentHashMap 是线程安全的，在并发环境下，如果调用get 方法获取到 null 之后，有可能是 key 不存在也有可能是key 存在，但是 value 为 null hashMap 是单线程所以能用 containsKey 方法判断有没有该key。但是如果并发下 concurentmap 如果调用containsKey 之前没有这个key，期望返回 false，但是调用之前可能有线程插入了这个key，结果返回 tue 了。 

### Redis 面试题

1. Redis 为什么快 
     * （1）Redis 使用了单线程架构+IO 多路复用模型
     * （2）纯内存访问 
     * （3）单线程避免了上下文切换带来的资源消耗2.什么是缓存击穿、缓存穿透、缓存雪崩常见的缓存使用方式：读请求来了，先查下缓存，缓存有值命中，就直接返回，缓存没命中，就去查数据库，然后把数据库的值更新到缓存，再返回。 
     * （1）缓存穿透 指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。如何避免缓存穿透？ ①如果是非法请求，我们在 API 入口，对参数进行校验，过滤非法值。 ②如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。 ③使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。 
     * （2）缓存雪崩 指同一个时刻缓存中数据大批量到过期时间失效，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。如何避免缓存雪崩？ 不要把所有 key 过期时间设置为一样的，让过期时间相对离散一点。如采用一个较大固定值+一个较小的随机值，5 小时+0 到1800秒这样。 
     * （3）缓存击穿 一个比较热门的键过期了，多个请求访问这个键，因为键不存在了，这将导致每次访问这个不存在的数据都是直接请求到数据库，增加数据库压力。 如何避免缓存击穿呢？ ①设置热门键不过期 ②考虑加分布式锁，获取锁的第一个线程把数据库数据拉出来加进缓存，后续的请求就不用去数据库查询了3.redis 字符串最大不能超过多少512M
2. Redis 默认分多少个数据库 

     * 16 个
3. Redis 过期策略 
     * （1）定时过期：每个设置过期时间的 key 都需要创建一个定时器，到过期时间就会立即对 key 进行清除。 
     * （2）惰性过期：只有当访问一个 key 时，才会判断该key 是否已过期，过期则清除。 
     * （3）定期过期：每隔一定的时间，会扫描一定数量的数据库的expires字典中一定数量的 key，并清除其中已过期的key。6.Redis 的持久化机制有哪些？优缺点说说
     * （1）RDB 就是把内存数据以快照的形式保存到磁盘上。RDB 持久化，是指在指定的时间间隔内，执行指定次数的写操作，将内存中的数据集快照写入磁盘中，它是 Redis 默认的持久化方式。执行完操作后，在指定目录下会生成一个 dump.rdb 文件，Redis 重启的时候，通过加载dump.rdb 文件来恢复数据。 RDB 的优点：适合大规模的数据恢复场景，如备份，全量复制等RDB 缺点：没办法做到实时持久化/秒级持久化。
     * （2）AOF 采用日志的形式来记录每个写操作，追加到文件中，重启时再重新执行 AOF 文件中的命令来恢复数据。它主要解决数据持久化的实时性问题。默认是不开启的。 AOF 的优点：数据的一致性和完整性更高AOF 的缺点：AOF 记录的内容越多，文件越大，数据恢复变慢。7.MySQL 与 Redis 如何保证双写一致性
     * （1）缓存延时双删：先删除缓存，再更新数据库，休眠一会（比如1 秒），再次删除缓存。 
     * （2）删除缓存重试机制：写请求更新数据库缓存因为某些原因，删除失败，把删除失败的 key 放到消息队列，消费消息队列的消息，获取要删除的 key 重试删除缓存操作 
     * （3）读取 biglog 异步删除缓存：以 mysql 为例，可以使用阿里的canal 将 binlog 日志采集发送到 MQ 队列里面，然后通过ACK 机制确认处理这条更新消息，删除缓存，保证数据缓存一致性
4. Redis 内存溢出策略

     * 当内存使用超过配置的时候会返回错误，不会删除任何键
     * 删除最久没有使用的键
     * 从所有 key 随机删除
     * 从过期键的集合中随机驱逐
     * 从所有键中驱逐使用频率最少的键 Mysql
     * 从设置了过期时间的键集合中驱逐最久没有使用的键
     * 从配置了过期时间的键中驱逐马上就要过期的键
     * 从所有配置了过期时间的键中驱逐使用频率最少的键

### Mysql 面试题

1. CHAR 和 VARCHAR 区别？ 
    * （1）char 表示定长，长度固定，varchar 表示变长，长度可变，char如果插入的长度小于定义长度时，用空格填充，varchar 小于定义长度时，还是按实际长度存储。 
    * （2）存储的容量不同，对 char 来说，最多能存放字符个数255，和编码无关，对 varchar 来说，最多存放 65532 个字符。
2. 索引是什么 
    * 一种有序的能够实现快速查找的数据结构。
3. 索引的分类 从物理结构上可以分为聚集索引和非聚集索引两类。从应用上可以划分为一下几类：普通索引、唯一索引（可以有null）、主键索引（不可以有 null）、联合索引。从数据结构上分有 Hash、BTree、B+Tree 等。4.索引设计原则？ 
    * （1）选择唯一性索引； 
    * （2）为经常作为查询条件的字段建立索引；
    * （3）为经常需要排序、分组和联合操作的字段建立索引；
    * （4）限制索引的数目； 
    * （5）小表不建议索引（如数量级在百万以内）；
    * （6）尽量使用数据量少的索引； 
    * （7）删除不再使用或者很少使用的索引；
    * （8）字段中重复值比较多的不适合建索引，比如性别；
    * （9）尽量使用前缀来索引，利用最左前缀。
4. 创建索引语句 

    - `creat index idx_user_nameEmail on user(name,email);`
5. 为何使用 B+树而非 B 树做索引？
    * （1）B+ 树减少了 IO 次数； 
    * （2）B+ 树查询效率更稳定（查找效率固定为O(log n)）； 
    * （3）B+ 树更加适合范围查找（B+树叶子结点之间用链表有序连接）。7.MyISAM 和 InnoDB 的区别？
    * （1）InnoDB 支持事务，MyISAM 不支持；
    * （2）InnoDB 支持外键，而 MyISAM 不支持；
    * （3）InnoDB 和 MyISAM 均支持 B+ Tree 数据结构的索引。但InnoDB是聚集索引，而 MyISAM 是非聚集索引；
    * （4）InnoDB 不保存表中数据行数，执行select count(*) fromtable时需要全表扫描。而 MyISAM 用一个变量记录了整个表的行数，速度相当快（注意不能有 WHERE 子句）； 
    * （5）InnoDB 支持表、行（默认）级锁，而MyISAM支持表级锁。8.什么是数据库的事务？ 数据库的事务是一个不可分割的数据库操作序列，事务是逻辑上的一组操作，要么都执行，要么都不执行。9.什么是事务的四大特性（ACID）？
    * （1）原子性：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
    * （2）一致性：事务执行前后，数据保持一致，多个事务对同一个数据读取的结果是相同的 
    * （3）隔离性：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的
    * （4）持久性：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
6. 什么是脏读、幻读和不可重复读？

    * （1）脏读：一个事务读取到另一个事务尚未提交的数据。事务A读取事务 B 更新的数据，然后 B 回滚操作，那么A 读取到的数据是脏数据。 
    * （2）不可重复读：一个事务中两次读取的数据的内容不一致。事务A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果不一致。
    * （3）幻读：一个事务中两次读取的数据量不一致。系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。
7. like 走索引吗？ 

     * xxx%走索引，%xxx 不走索引
8. 如果我就想用 like，如何保证不失效？

    * 使用覆盖索引。
9. 什么是覆盖索引？ 

     * 如果一个索引包含（覆盖）所有需要查询的字段的值，称为覆盖索引。
10. 索引不生效的情况 

     * （1）不满足最左匹配原则 
     * （2）使用不等于查询 
     * （3）在索引列上使用了函数 
     * （4）使用范围条件，范围之后全失效 
     * （5）使用 like 时左边是通配符 
     * （6）使用 is null 和 is not null 
     * （7）字符串不加单引号 
     * （8）用 or 也可能导致索引失效
11. 如何获取 select 语句执行计划

      * explain sql; 其中重点查看 possible_keys 和 key。 
      * possible_keys：显示可能应用在这张表中的索引，一个或多个。查询到的索引不一定是真正被使用。 
      * Key：实际使用的索引，如果为 null 则表示没有使用索引。因此会出现 possible_keys 列有可能被用到的索引，但是key 列为null。
12. sql 调优 

      * 在 mysql 配置文件里开启慢查询，可以设置指定的秒数，然后他会把超过这个秒数的 sql 语句放到指定文件,然后我们将这个sql 取出来
      * 通过 explain 分析，查看 prossible_keys 和key，然后看有没有导致文件内排序。 

### Spring 面试题

1. Spring 用到了哪些设计模式？
     * （1）简单工厂模式：BeanFactory 就是简单工厂模式的体现，根据传入一个唯一标识来获得 Bean 对象。 
     * （2）工厂方法模式：FactoryBean 就是典型的工厂方法模式。spring在使用getBean()调用获得该bean时，会自动调用该bean的getObject() 方法。每个 Bean 都会对应一个 FactoryBean，如SqlSessionFactory对应 SqlSessionFactoryBean。 
     * （3）单例模式：一个类仅有一个实例，提供一个访问它的全局访问点。Spring 创建 Bean 实例默认是单例的。
     * （4）适配器模式：SpringMVC 中的适配器HandlerAdatper。由于应用会有多个 Controller 实现，如果需要直接调用Controller 方法，那么需要先判断是由哪一个 Controller 处理请求，然后调用相应的方法。当增加新的 Controller，需要修改原来的逻辑，违反了开闭原则（对修改关闭，对扩展开放）。 
     * （5）代理模式：Spring 的 aop 使用了动态代理，有两种方式JdkDynamicAopProxy 和 Cglib2AopProxy。 
     * （6）观察者模式：Spring 中 observer 模式常用的地方是listener 的实现，如 ApplicationListener。 
     * （7）模板模式： Spring 中 jdbcTemplate、hibernateTemplate 等，就使用到了模板模式。

25. 什么是 AOP？ 
    
    * 面向切面编程，作为面向对象的一种补充，将公共逻辑（事务管理、日志、缓存等）封装成切面，跟业务代码进行分离，可以减少系统的重复代码和降低模块之间的耦合度。切面就是那些与业务无关，但所有业务模块都会调用的公共逻辑。

3. AOP 有哪些实现方式？ 

     * AOP 有两种实现方式：静态代理和动态代理。

      * （1）静态代理 代理类在编译阶段生成，在编译阶段将通知织入Java 字节码中，也称编译时增强。AspectJ 使用的是静态代理。缺点：代理对象需要与目标对象实现一样的接口，并且实现接口的方法，会有冗余代码。同时，一旦接口增加方法，目标对象与代理对象都要维护。 
      * （2）动态代理 代理类在程序运行时创建，AOP 框架不会去修改字节码，而是在内存中临时生成一个代理对象，在运行期间对业务方法进行增强，不会生成新类。

4. JDK 动态代理和 CGLIB 动态代理的区别？ 
      * （1）JDK 动态代理 如果目标类实现了接口，Spring AOP 会选择使用JDK 动态代理目标类。代理类根据目标类实现的接口动态生成，不需要自己编写，生成的动态代理类和目标类都实现相同的接口。JDK 动态代理的核心是InvocationHandler 接口和 Proxy 类。 缺点：目标类必须有实现的接口。如果某个类没有实现接口，那么这个类就不能用 JDK 动态代理。 
      * （2）CGLIB 动态代理 通过继承实现。如果目标类没有实现接口，那么Spring AOP会选择使用 CGLIB 来动态代理目标类。CGLIB（Code Generation Library）可以在运行时动态生成类的字节码，动态创建目标类的子类对象，在子类对象中增强目标类。 CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final，那么它是无法使用 CGLIB 做动态代理的。优点：目标类不需要实现特定的接口，更加灵活。
      * （3）什么时候采用哪种动态代理？ ①如果目标对象实现了接口，默认情况下会采用JDK 的动态代理实现AOP ②如果目标对象实现了接口，可以强制使用CGLIB 实现AOP ③如果目标对象没有实现了接口，必须采用CGLIB 库
      * （4）两者的区别： jdk 动态代理使用 jdk 中的类 Proxy 来创建代理对象，它使用反射 技术来实现，不需要导入其他依赖。cglib 需要引入相关依赖：asm.jar，它使用字节码增强技术来实现。 当目标类实现了接口的时候 Spring Aop 默认使用jdk 动态代理方式来增强方法，没有实现接口的时候使用cglib 动态代理方式增强方法。

5. 什么是 IOC？ 

      * 控制反转，由 Spring 容器管理 bean 的整个生命周期。通过反射实现对其他对象的控制，包括初始化、创建、销毁等，解放手动创建对象的过程，同时降低类之间的耦合度。IOC 的好处：降低了类之间的耦合，对象创建和初始化交给Spring容器管理，在需要的时候只需向容器进行申请。

6. IOC 的优点是什么？ 
      * （1）IOC 和依赖注入降低了应用的代码量。
      * （2）松耦合。 
      * （3）支持加载服务时的饿汉式初始化和懒加载。

7. 什么是依赖注入？ 

      * 在 Spring 创建对象的过程中，把对象依赖的属性注入到对象中。依赖注入主要有两种方式：构造器注入和属性注入。

8. Bean 的生命周期

      * （1）对 Bean 进行实例化 
      * （2）给 bean 注入属性 
      * （3）如果 Bean 实现了 aware 接口，会执行接口对应的方法。 
      * （4）如果存在后置处理器，Spring 将调用它们的后置处理器的前置方法 
      * （5）执行初始化方法 
      * （6）如果存在后置处理器，调用后置处理器的后置方法（apo就是在这一步进行的） 
      * （7）Bean 初始化完成

9. BeanFactory 和 FactoryBean 的区别？

      * BeanFactory 是个 Factory，也就是 IOC 容器或对象⼯⼚，FactoryBean是个 Bean。在 Spring 中，所有的 Bean 都是由BeanFactory(也就是IOC容器)来进⾏管理的。 但对 FactoryBean⽽⾔，这个Bean 不是简单的Bean，⽽是⼀个能⽣产或者修饰对象⽣成的⼯⼚Bean, 它的实现与设计模式中的⼯⼚模式和修饰器模式类似

10. Spring 自动装配的方式有哪些？

      * Spring 的自动装配有三种模式：byType(根据类型)，byName(根据名称)、constructor(根据构造函数)。 (1)byType 找到与依赖类型相同的 bean 注入到另外的bean 中，这个过程需要借助 setter 注入来完成，因此必须存在 set 方法，否则注入失败。(2)byName 将属性名与 bean 名称进行匹配，如果找到则注入依赖bean。

11. @Autowired 和@Resource 的区别？

       * @Autowired 注解是按照类型（byType）装配依赖对象的，但是存在多 个类型⼀致的 bean，⽆法通过 byType 注⼊时，就会再使⽤byName来 注入 ，如 果 还 是 ⽆ 法 判 断注⼊哪个bean则会UnsatisfiedDependencyException。 
       * @Resource 会首先按照byName来装配，如果找不到 bean，会⾃动 byType 再找⼀次。

12. @Bean 和@Component 有什么区别？

       * 都是使用注解定义 Bean。@Bean 是使用Java 代码装配Bean，@Component 是自动装配 Bean。 

          * （1）@Component 注解用在类上，表明一个类会作为组件类，并告知 Spring 要为这个类创建 bean，每个类对应一个Bean。
          * （2）@Bean 注解用在方法上，表示这个方法会返回一个Bean。@Bean需要在配置类中使用，即类上需要加上@Configuration 注解。

13. Spring 事务实现方式有哪些？

       * Spring 事务机制主要包括声明式事务和编程式事务。使用 @Transactional 注解开启声明式事务。15.有哪些事务传播行为？ 常用的就 2 种，required 和 required new

14. required 和 required new 的区别: 
          * （1）使用 required，内层事务与外层事务共用一个事务，出现异常同时回滚。 
          * （2）使用 required new 时，内层事务与外层事务是两个独立的事务。一旦内层事务进行了提交后，外层事务不能对其进行回滚。两个事务互不影响。

15. Spring 的单例 Bean 是否有线程安全问题？

          * （1）有实例变量的 bean 是有状态的 bean，是非线程安全的。
            
          * （2）没有实例变量的对象是无状态的 bean，是线程安全的。Bean 在多线程环境下不安全，一般用Prototype 模式或者使用ThreadLocal 解决线程安全问题。

### MyBatis

1. #{}和${}的区别是什么？
      * #{} 是预编译处理，${}是字符串替换。 使用#{}可以有效的防止 SQL 注入，${}不可以#{}传过来的参数带单引号''，而${}传过来的参数不带单引号。
2. mybatis 什么时候用的${} 

      * 动态表名字以及 ordery by 后面的字段，因为#{}传过来的参数带单引号''，而${}传过来的参数不带单引号。
3. 当实体类中的属性名和表中的字段名不一样，怎么办？
      * （1）通过在查询的 sql 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。 
      * （2）通过 resultmap 来映射字段名和实体类属性名的对应的关系。
4. Mybatis 是如何进行分页的？
      * 分页插件的原理是什么？Mybatis 使用 RowBounds 对象进行逻辑分页，它是针对ResultSet 结果集执行的内存分页。分页插件的基本原理是使用Mybatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写 sql，添加对应的物理分页语句和物理分页参数。
5. MyBatis 实现一对一有几种方式?

      * 具体怎么操作的？有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面的 collection 节点配置一对多的类；嵌套查询是先查一个表,根据这个表里面的 结果的外键id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过select 节点配置。
6. MyBatis 实现一对多有几种方式,怎么操作的？
      * 有联合查询和嵌套查询。联合查询是几个表联合查询,只查询一次,通过在 resultMap 里面的 collection 节点配置一对多的类就可以完成；嵌套查询是先查一个表,根据这个表里面的结果的外键id,去再另外一个表里面查询数据,也是通过配置 collection,但另外一个表的查询通过 select 节点配置
7. Mybatis 的一级、二级缓存 一级缓存: 基于 PerpetualCache 的HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该Session中的所有 Cache 就将清空，默认打开一级缓存。二级缓存与一级缓存其机制相同，默认也是采用PerpetualCache，HashMap 存储，不同在于其存储作用域为Mapper(Namespace)，并且可自定义存储源，默认不开启二级缓存缓存。
8. Mybatis Mapper 接口支持重载吗？
    * 不支持 因为 mybatis 是根据 package+Mapper+method 全限名作为key，去 xml 内寻找唯一 sql 来执行的。如果方法名一样会导致找到两个sql 报错。 SpringBoot
8. 有什么好处 
      * （1）简化了原来 spring 及 springmvc 一大堆配置文件
      * （2）嵌入的 Tomcat 不需要以 war 包形式部署
      * （3）进行 maven 依赖包版本统一管理
10. SpringBoot 自动配置的原理是什么
      * 主要是 Spring Boot 的启动类上的核心注解SpringBootApplication注解主配置类，有了这个主配置，类启动时就会为SpringBoot 开启一个@EnableAutoConfiguration 注解自动配置功能。有了这个 EnableAutoConfiguration 的话就会：从配置文件 META_INF/Spring.factories 加载可能用到的自动配置类去重，并将 exclude 和 excludeName 属性携带的类排除过滤，将满足条件（@Conditional）的自动配置类返回。每个类又有自己的一个属性类，每个属性类的属性又从 springboot 的配置文件中读取。

### JVM

1. 内存模型 堆 -Xm（s 最小堆内存）和-Xmx（最大堆内存）可以指定堆的大小,jdk1.8把静态变量移到了堆中，字符串常量池 StringTable 也移到了堆中，堆又分为年轻代（复制算法清除垃圾，速度快，避免内存碎片，细分为 伊甸园区和幸存者 0 区幸存者 1 区，年轻代内存比8:1:1），和老年代（标记整理算法）这两块幸存者区域采用复制算法进行垃圾回收虚拟机栈 每个方法被执行的时候都会创建一个栈帧虚拟机栈由细分为局部变量表、操作栈、动态链接、方法方法放回地址 本地方法栈 虚拟机使用到的 Native（C 语言）方法服务元空间 存储已被虚拟机加载的类的信息以及运行时常量池程序计数器 当前线程所执行在那一行做一个计数

2. JVM 垃圾回收算法 

   * （1）标记-清除：标记哪些要被回收的对象，然后统一回收但是会有两个主要问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片。 

   * （2）复制算法：速度快，没有内存碎片，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清除完第一块内存，再将第二块上的对象复制到第一块。缺点是要浪费内存，因为 8：1：1 有一半内存要浪费 

   * （3）标记-整理：解决了内存碎片的问题，消除了复制算法当中，内存减半的问题，但是效率低于复制算法，并且会暂停用户线程3.垃圾回收器 需要学习两款垃圾回收器 G1 和 CMS，需要知道两者的区别，应用场景，以及两者是怎么工作的，这个需要自己去学，面试题写了没 学过也很难背。需要学习一款堆分析工具，mat，这两个都可以看尚硅谷宋红康 jvm 视频。 SpringcloudAlibaba（了解即可，可以晚上学一下整理的视频，面试题常见就这些）
         
     

3. 你知道哪些组件，都干嘛的

    * （1）Sentinel：流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。 
    * （2）Nacos：注册中心、配置管理。 
    * （3）Openfign：服务之间的远程调用 
    * （4）Seata：处理微服务分布式事务

4. Springboot 与 SpringCloud 区别

    * Spring boot 是 Spring 的一套快速配置脚手架，可以基于SpringBoot 快速开发单个微服务；Spring Cloud 是一个基于Spring Boot 实现的微服务开发框架。 Spring Boot 可以快速、方便集成单个个体,Spring Cloud 是关注全局的服务治理框架。

5. 你知道有哪些注册中心 
    * （1）ZooKeeper CP 
    * （2）Eureka AP 
    * （3）Consul CP 
    * （4）Nacos CP+AP

6. 什么是 cap 理论

    * 一个分布式系统最多只能满足 CAP 中的两个条件，不可能同时满足三个条件 

    * （1）C（Consistency）：这里指的是强一致性。保证在一定时间内，集群中的各个节点会达到较强的一致性，
    * （2）A (Avalibility)：可用性。意味着系统一直处于可用状态。个别节点的故障不会影响整个服务的运作 
    * （3）P（Partition Tolerance)：分区容忍性。当系统出现网络分区等情况时，依然能对外提供服务。 Rocketmq，rabbitmq：记住几个常见面试题：消息丢失，重复消费，消息积压解决方法以及顺序消息怎么发送即可。